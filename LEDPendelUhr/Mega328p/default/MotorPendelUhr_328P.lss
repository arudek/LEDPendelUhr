
MotorPendelUhr_328P.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000150  00800100  00001278  0000132c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001278  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000175  00800250  00800250  0000147c  2**0
                  ALLOC
  3 .eeprom       00000115  00810000  00810000  0000147c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000080  00000000  00000000  00001591  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000002ba  00000000  00000000  00001611  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000fa8  00000000  00000000  000018cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000672  00000000  00000000  00002873  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cb9  00000000  00000000  00002ee5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000220  00000000  00000000  00003ba0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005a7  00000000  00000000  00003dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000005a0  00000000  00000000  00004367  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 3a 01 	jmp	0x274	; 0x274 <__vector_1>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 0e 01 	jmp	0x21c	; 0x21c <__vector_3>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 82 00 	jmp	0x104	; 0x104 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 ea 00 	jmp	0x1d4	; 0x1d4 <__vector_14>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__vector_18>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	12 e0       	ldi	r17, 0x02	; 2
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 e7       	ldi	r30, 0x78	; 120
      7c:	f2 e1       	ldi	r31, 0x12	; 18
      7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
      84:	a0 35       	cpi	r26, 0x50	; 80
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
      8a:	13 e0       	ldi	r17, 0x03	; 3
      8c:	a0 e5       	ldi	r26, 0x50	; 80
      8e:	b2 e0       	ldi	r27, 0x02	; 2
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a5 3c       	cpi	r26, 0xC5	; 197
      96:	b1 07       	cpc	r27, r17
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 5e 01 	call	0x2bc	; 0x2bc <main>
      9e:	0c 94 3a 09 	jmp	0x1274	; 0x1274 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <setTime>:
    for (;;) {}   	// loop forever   
}

void setTime(uint8_t h, uint8_t m, uint8_t s, uint16_t millisec)
{
	hours=h;
      a6:	80 93 52 02 	sts	0x0252, r24
	minutes=m;
      aa:	60 93 53 02 	sts	0x0253, r22
	seconds=s;
      ae:	40 93 54 02 	sts	0x0254, r20
	ms=millisec;
      b2:	30 93 51 02 	sts	0x0251, r19
      b6:	20 93 50 02 	sts	0x0250, r18
}
      ba:	08 95       	ret

000000bc <__vector_18>:

}*/

/* Interrupt für eingehende Bytes an uart */
SIGNAL (USART_RX_vect) 
{
      bc:	1f 92       	push	r1
      be:	0f 92       	push	r0
      c0:	0f b6       	in	r0, 0x3f	; 63
      c2:	0f 92       	push	r0
      c4:	11 24       	eor	r1, r1
      c6:	2f 93       	push	r18
      c8:	3f 93       	push	r19
      ca:	4f 93       	push	r20
      cc:	5f 93       	push	r21
      ce:	6f 93       	push	r22
      d0:	7f 93       	push	r23
      d2:	8f 93       	push	r24
      d4:	9f 93       	push	r25
      d6:	af 93       	push	r26
      d8:	bf 93       	push	r27
      da:	ef 93       	push	r30
      dc:	ff 93       	push	r31
	USART_RX_INT();
      de:	0e 94 b2 05 	call	0xb64	; 0xb64 <USART_RX_INT>
}
      e2:	ff 91       	pop	r31
      e4:	ef 91       	pop	r30
      e6:	bf 91       	pop	r27
      e8:	af 91       	pop	r26
      ea:	9f 91       	pop	r25
      ec:	8f 91       	pop	r24
      ee:	7f 91       	pop	r23
      f0:	6f 91       	pop	r22
      f2:	5f 91       	pop	r21
      f4:	4f 91       	pop	r20
      f6:	3f 91       	pop	r19
      f8:	2f 91       	pop	r18
      fa:	0f 90       	pop	r0
      fc:	0f be       	out	0x3f, r0	; 63
      fe:	0f 90       	pop	r0
     100:	1f 90       	pop	r1
     102:	18 95       	reti

00000104 <__vector_11>:
{
	ledText_tick();
}

SIGNAL (TIMER1_COMPA_vect)		// Timer für dcf77
{
     104:	1f 92       	push	r1
     106:	0f 92       	push	r0
     108:	0f b6       	in	r0, 0x3f	; 63
     10a:	0f 92       	push	r0
     10c:	11 24       	eor	r1, r1
     10e:	2f 93       	push	r18
     110:	3f 93       	push	r19
     112:	4f 93       	push	r20
     114:	5f 93       	push	r21
     116:	6f 93       	push	r22
     118:	7f 93       	push	r23
     11a:	8f 93       	push	r24
     11c:	9f 93       	push	r25
     11e:	af 93       	push	r26
     120:	bf 93       	push	r27
     122:	ef 93       	push	r30
     124:	ff 93       	push	r31
	ms++; //=10;
     126:	80 91 50 02 	lds	r24, 0x0250
     12a:	90 91 51 02 	lds	r25, 0x0251
     12e:	01 96       	adiw	r24, 0x01	; 1
     130:	90 93 51 02 	sts	0x0251, r25
     134:	80 93 50 02 	sts	0x0250, r24

	
	if (ms>999) 
     138:	80 91 50 02 	lds	r24, 0x0250
     13c:	90 91 51 02 	lds	r25, 0x0251
     140:	88 5e       	subi	r24, 0xE8	; 232
     142:	93 40       	sbci	r25, 0x03	; 3
     144:	b4 f1       	brlt	.+108    	; 0x1b2 <__vector_11+0xae>
	{
		ms-=1000;
     146:	80 91 50 02 	lds	r24, 0x0250
     14a:	90 91 51 02 	lds	r25, 0x0251
     14e:	88 5e       	subi	r24, 0xE8	; 232
     150:	93 40       	sbci	r25, 0x03	; 3
     152:	90 93 51 02 	sts	0x0251, r25
     156:	80 93 50 02 	sts	0x0250, r24
		if (seconds<59)	seconds++;
     15a:	80 91 54 02 	lds	r24, 0x0254
     15e:	8b 33       	cpi	r24, 0x3B	; 59
     160:	30 f4       	brcc	.+12     	; 0x16e <__vector_11+0x6a>
     162:	80 91 54 02 	lds	r24, 0x0254
     166:	8f 5f       	subi	r24, 0xFF	; 255
     168:	80 93 54 02 	sts	0x0254, r24
     16c:	1a c0       	rjmp	.+52     	; 0x1a2 <__vector_11+0x9e>
		else 
		{
			seconds=0;
     16e:	10 92 54 02 	sts	0x0254, r1
			if (minutes<59)
     172:	80 91 53 02 	lds	r24, 0x0253
     176:	8b 33       	cpi	r24, 0x3B	; 59
     178:	30 f4       	brcc	.+12     	; 0x186 <__vector_11+0x82>
				minutes++;
     17a:	80 91 53 02 	lds	r24, 0x0253
     17e:	8f 5f       	subi	r24, 0xFF	; 255
     180:	80 93 53 02 	sts	0x0253, r24
     184:	0e c0       	rjmp	.+28     	; 0x1a2 <__vector_11+0x9e>
			else
			{
				minutes=0;
     186:	10 92 53 02 	sts	0x0253, r1
				if (hours<23)
     18a:	80 91 52 02 	lds	r24, 0x0252
     18e:	87 31       	cpi	r24, 0x17	; 23
     190:	30 f4       	brcc	.+12     	; 0x19e <__vector_11+0x9a>
					hours++;
     192:	80 91 52 02 	lds	r24, 0x0252
     196:	8f 5f       	subi	r24, 0xFF	; 255
     198:	80 93 52 02 	sts	0x0252, r24
     19c:	02 c0       	rjmp	.+4      	; 0x1a2 <__vector_11+0x9e>
				else 
					hours=0;
     19e:	10 92 52 02 	sts	0x0252, r1
			}
		}
		changeTime(hours, minutes, seconds);
     1a2:	80 91 52 02 	lds	r24, 0x0252
     1a6:	60 91 53 02 	lds	r22, 0x0253
     1aa:	40 91 54 02 	lds	r20, 0x0254
     1ae:	0e 94 2e 05 	call	0xa5c	; 0xa5c <changeTime>
	}

/*	uint8_t inp=(PIND & (1<<PORTD3));	// Pin auslesen
	dcf77_processBit(inp, (uint8_t *)&hours, (uint8_t*)&minutes, (uint8_t*)&seconds, (int*)&ms);
	TCNT1=0;
*/}
     1b2:	ff 91       	pop	r31
     1b4:	ef 91       	pop	r30
     1b6:	bf 91       	pop	r27
     1b8:	af 91       	pop	r26
     1ba:	9f 91       	pop	r25
     1bc:	8f 91       	pop	r24
     1be:	7f 91       	pop	r23
     1c0:	6f 91       	pop	r22
     1c2:	5f 91       	pop	r21
     1c4:	4f 91       	pop	r20
     1c6:	3f 91       	pop	r19
     1c8:	2f 91       	pop	r18
     1ca:	0f 90       	pop	r0
     1cc:	0f be       	out	0x3f, r0	; 63
     1ce:	0f 90       	pop	r0
     1d0:	1f 90       	pop	r1
     1d2:	18 95       	reti

000001d4 <__vector_14>:
	}

}

SIGNAL (TIMER0_COMPA_vect)    // Timer für LEDs
{
     1d4:	1f 92       	push	r1
     1d6:	0f 92       	push	r0
     1d8:	0f b6       	in	r0, 0x3f	; 63
     1da:	0f 92       	push	r0
     1dc:	11 24       	eor	r1, r1
     1de:	2f 93       	push	r18
     1e0:	3f 93       	push	r19
     1e2:	4f 93       	push	r20
     1e4:	5f 93       	push	r21
     1e6:	6f 93       	push	r22
     1e8:	7f 93       	push	r23
     1ea:	8f 93       	push	r24
     1ec:	9f 93       	push	r25
     1ee:	af 93       	push	r26
     1f0:	bf 93       	push	r27
     1f2:	ef 93       	push	r30
     1f4:	ff 93       	push	r31
	ledText_tick();
     1f6:	0e 94 9a 03 	call	0x734	; 0x734 <ledText_tick>
}
     1fa:	ff 91       	pop	r31
     1fc:	ef 91       	pop	r30
     1fe:	bf 91       	pop	r27
     200:	af 91       	pop	r26
     202:	9f 91       	pop	r25
     204:	8f 91       	pop	r24
     206:	7f 91       	pop	r23
     208:	6f 91       	pop	r22
     20a:	5f 91       	pop	r21
     20c:	4f 91       	pop	r20
     20e:	3f 91       	pop	r19
     210:	2f 91       	pop	r18
     212:	0f 90       	pop	r0
     214:	0f be       	out	0x3f, r0	; 63
     216:	0f 90       	pop	r0
     218:	1f 90       	pop	r1
     21a:	18 95       	reti

0000021c <__vector_3>:
}

/* signal handler for external interrupt int0 */

SIGNAL(PCINT0_vect)     		// Taster
{
     21c:	1f 92       	push	r1
     21e:	0f 92       	push	r0
     220:	0f b6       	in	r0, 0x3f	; 63
     222:	0f 92       	push	r0
     224:	11 24       	eor	r1, r1
     226:	2f 93       	push	r18
     228:	3f 93       	push	r19
     22a:	4f 93       	push	r20
     22c:	5f 93       	push	r21
     22e:	6f 93       	push	r22
     230:	7f 93       	push	r23
     232:	8f 93       	push	r24
     234:	9f 93       	push	r25
     236:	af 93       	push	r26
     238:	bf 93       	push	r27
     23a:	ef 93       	push	r30
     23c:	ff 93       	push	r31
	uint8_t inp = PINB;
     23e:	83 b1       	in	r24, 0x03	; 3

	if ((inp & (1<<PORTB0)) >0)
     240:	80 ff       	sbrs	r24, 0
     242:	02 c0       	rjmp	.+4      	; 0x248 <__vector_3+0x2c>
	{
		setTextId(0);
     244:	80 e0       	ldi	r24, 0x00	; 0
     246:	03 c0       	rjmp	.+6      	; 0x24e <__vector_3+0x32>
	}
	else if ((inp & (1<<PORTB1)) > 0)
     248:	81 ff       	sbrs	r24, 1
     24a:	03 c0       	rjmp	.+6      	; 0x252 <__vector_3+0x36>
	{
		setTextId(1);
     24c:	81 e0       	ldi	r24, 0x01	; 1
     24e:	0e 94 19 03 	call	0x632	; 0x632 <setTextId>
	}

}
     252:	ff 91       	pop	r31
     254:	ef 91       	pop	r30
     256:	bf 91       	pop	r27
     258:	af 91       	pop	r26
     25a:	9f 91       	pop	r25
     25c:	8f 91       	pop	r24
     25e:	7f 91       	pop	r23
     260:	6f 91       	pop	r22
     262:	5f 91       	pop	r21
     264:	4f 91       	pop	r20
     266:	3f 91       	pop	r19
     268:	2f 91       	pop	r18
     26a:	0f 90       	pop	r0
     26c:	0f be       	out	0x3f, r0	; 63
     26e:	0f 90       	pop	r0
     270:	1f 90       	pop	r1
     272:	18 95       	reti

00000274 <__vector_1>:
	ms=millisec;
}

// Lichtschranke:
SIGNAL(INT0_vect)
{
     274:	1f 92       	push	r1
     276:	0f 92       	push	r0
     278:	0f b6       	in	r0, 0x3f	; 63
     27a:	0f 92       	push	r0
     27c:	11 24       	eor	r1, r1
     27e:	2f 93       	push	r18
     280:	3f 93       	push	r19
     282:	4f 93       	push	r20
     284:	5f 93       	push	r21
     286:	6f 93       	push	r22
     288:	7f 93       	push	r23
     28a:	8f 93       	push	r24
     28c:	9f 93       	push	r25
     28e:	af 93       	push	r26
     290:	bf 93       	push	r27
     292:	ef 93       	push	r30
     294:	ff 93       	push	r31
	ledText_beginSequence();
     296:	0e 94 1c 03 	call	0x638	; 0x638 <ledText_beginSequence>
	//TCNT0=0;
}
     29a:	ff 91       	pop	r31
     29c:	ef 91       	pop	r30
     29e:	bf 91       	pop	r27
     2a0:	af 91       	pop	r26
     2a2:	9f 91       	pop	r25
     2a4:	8f 91       	pop	r24
     2a6:	7f 91       	pop	r23
     2a8:	6f 91       	pop	r22
     2aa:	5f 91       	pop	r21
     2ac:	4f 91       	pop	r20
     2ae:	3f 91       	pop	r19
     2b0:	2f 91       	pop	r18
     2b2:	0f 90       	pop	r0
     2b4:	0f be       	out	0x3f, r0	; 63
     2b6:	0f 90       	pop	r0
     2b8:	1f 90       	pop	r1
     2ba:	18 95       	reti

000002bc <main>:


int main(void)
{
	// Port C konfigurieren (LEDs 0-5): 
	PORTC = 0x0; 
     2bc:	18 b8       	out	0x08, r1	; 8
    DDRC  = 0b00111111;       // PortC (LEDs) auf Ausgang 
     2be:	8f e3       	ldi	r24, 0x3F	; 63
     2c0:	87 b9       	out	0x07, r24	; 7
	
	// PortD.6,7=LED6,7
	// Rest auf Eingang
	PORTD=0b00111111; 		//pullups hoch
     2c2:	8b b9       	out	0x0b, r24	; 11
	DDRD =0b11000000;		// PortD0-5 auf Eingang
     2c4:	80 ec       	ldi	r24, 0xC0	; 192
     2c6:	8a b9       	out	0x0a, r24	; 10

	EICRA = (1<<ISC01) | (0<<ISC00);	// on falling edge
     2c8:	82 e0       	ldi	r24, 0x02	; 2
     2ca:	80 93 69 00 	sts	0x0069, r24
//	EICRA = (1<<ISC01) | (1<<ISC00);	// on rising edge
	EIMSK = (1<<INT0);					// enable int0
     2ce:	81 e0       	ldi	r24, 0x01	; 1
     2d0:	8d bb       	out	0x1d, r24	; 29


	// Port B konfigurieren (Taster):
	DDRB = 0;				// PortB auf Eingang
     2d2:	14 b8       	out	0x04, r1	; 4
	PORTB |= (1<<PORTB0);	// pullup an PCINT0 (T1) hoch
     2d4:	28 9a       	sbi	0x05, 0	; 5
	PORTB |= (1<<PORTB1);	// pullup an PCINT1 (T2) hoch
     2d6:	29 9a       	sbi	0x05, 1	; 5
	
	// Timer 0 konfigurieren (LEDs):
	TCCR0B |= (1<<CS01); 	// Prescaler 8
     2d8:	85 b5       	in	r24, 0x25	; 37
     2da:	82 60       	ori	r24, 0x02	; 2
     2dc:	85 bd       	out	0x25, r24	; 37
	TCCR0A |= (1<<WGM01);				// CTC (Counter läuft nur bis OCRA)
     2de:	84 b5       	in	r24, 0x24	; 36
     2e0:	82 60       	ori	r24, 0x02	; 2
     2e2:	84 bd       	out	0x24, r24	; 36
//	TCCR0A |= (1<<COM0A1);				// Kein Signal auf PortD6 ausgeben
	OCR0A = INT_TIMER_T0;				// für LEDs
     2e4:	83 e5       	ldi	r24, 0x53	; 83
     2e6:	87 bd       	out	0x27, r24	; 39
	TIMSK0 |= (1<<OCIE0A);				
     2e8:	80 91 6e 00 	lds	r24, 0x006E
     2ec:	82 60       	ori	r24, 0x02	; 2
     2ee:	80 93 6e 00 	sts	0x006E, r24

	// Timer 1 konfigurieren (Funkuhr):
    TCCR1B |= (1<<CS12) | (1<<WGM12);	// CS12: CLK/256; WGM12: Limit in OCR1A definiert (CTC)
     2f2:	80 91 81 00 	lds	r24, 0x0081
     2f6:	8c 60       	ori	r24, 0x0C	; 12
     2f8:	80 93 81 00 	sts	0x0081, r24
	OCR1A = INT_TIMER_T1;   			// Timer auf 10ms
     2fc:	8f e1       	ldi	r24, 0x1F	; 31
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	90 93 89 00 	sts	0x0089, r25
     304:	80 93 88 00 	sts	0x0088, r24
	TIMSK1  |= (1<<OCIE1A);				// Int, wenn TCNT1==OCR1A	            
     308:	80 91 6f 00 	lds	r24, 0x006F
     30c:	82 60       	ori	r24, 0x02	; 2
     30e:	80 93 6f 00 	sts	0x006F, r24
	ASSR |= (1<<AS2);
*/

	
	// Pin Change Interrrupts konfigurieren (Taster):
	PCICR |= (1<<PCIE0);					// PCIE0 aktivieren (PCINT0-PCINT7)
     312:	80 91 68 00 	lds	r24, 0x0068
     316:	81 60       	ori	r24, 0x01	; 1
     318:	80 93 68 00 	sts	0x0068, r24
	PCMSK0 |= (1<<PCINT0) | (1<<PCINT1);	// PCINT0-3 aktivieren
     31c:	80 91 6b 00 	lds	r24, 0x006B
     320:	83 60       	ori	r24, 0x03	; 3
     322:	80 93 6b 00 	sts	0x006B, r24


	ledText_init();
     326:	0e 94 9f 04 	call	0x93e	; 0x93e <ledText_init>

	USART_Init();
     32a:	0e 94 58 05 	call	0xab0	; 0xab0 <USART_Init>


	sei();			// Interrupts aktivieren
     32e:	78 94       	sei
     330:	ff cf       	rjmp	.-2      	; 0x330 <main+0x74>

00000332 <dcf77_getParityBit>:

}


uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	20 e0       	ldi	r18, 0x00	; 0
     336:	30 e0       	ldi	r19, 0x00	; 0
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
		sum += m_dcf77_buffer[i];
     338:	48 2f       	mov	r20, r24
     33a:	50 e0       	ldi	r21, 0x00	; 0

uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
     33c:	70 e0       	ldi	r23, 0x00	; 0
     33e:	06 c0       	rjmp	.+12     	; 0x34c <dcf77_getParityBit+0x1a>
		sum += m_dcf77_buffer[i];
     340:	e7 5a       	subi	r30, 0xA7	; 167
     342:	fd 4f       	sbci	r31, 0xFD	; 253
     344:	80 81       	ld	r24, Z
     346:	98 0f       	add	r25, r24
     348:	2f 5f       	subi	r18, 0xFF	; 255
     34a:	3f 4f       	sbci	r19, 0xFF	; 255
     34c:	f9 01       	movw	r30, r18
     34e:	e4 0f       	add	r30, r20
     350:	f5 1f       	adc	r31, r21

uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
     352:	6e 17       	cp	r22, r30
     354:	7f 07       	cpc	r23, r31
     356:	a4 f7       	brge	.-24     	; 0x340 <dcf77_getParityBit+0xe>
     358:	40 e0       	ldi	r20, 0x00	; 0
     35a:	29 2f       	mov	r18, r25
     35c:	30 e0       	ldi	r19, 0x00	; 0
     35e:	96 95       	lsr	r25
     360:	89 2f       	mov	r24, r25
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	88 0f       	add	r24, r24
     366:	99 1f       	adc	r25, r25
     368:	28 17       	cp	r18, r24
     36a:	39 07       	cpc	r19, r25
     36c:	09 f0       	breq	.+2      	; 0x370 <dcf77_getParityBit+0x3e>
     36e:	41 e0       	ldi	r20, 0x01	; 1

	if (sum==((sum>>1)<<1))
		return 0;
	
	return 1;
}
     370:	84 2f       	mov	r24, r20
     372:	08 95       	ret

00000374 <dcf77_processTimeBuffer>:

void dcf77_processTimeBuffer(uint8_t *hr, uint8_t *min, uint8_t *sec)
{
     374:	ef 92       	push	r14
     376:	ff 92       	push	r15
     378:	0f 93       	push	r16
     37a:	1f 93       	push	r17
     37c:	cf 93       	push	r28
     37e:	df 93       	push	r29
     380:	ec 01       	movw	r28, r24
     382:	8b 01       	movw	r16, r22
     384:	7a 01       	movw	r14, r20
	if (!m_dcf77_validData)
     386:	80 91 55 02 	lds	r24, 0x0255
     38a:	88 23       	and	r24, r24
     38c:	09 f4       	brne	.+2      	; 0x390 <dcf77_processTimeBuffer+0x1c>
     38e:	bb c0       	rjmp	.+374    	; 0x506 <dcf77_processTimeBuffer+0x192>
		return;

	if (m_dcf77_buffer[0]!=0)	// 1. Bit muss 1 sein
     390:	80 91 59 02 	lds	r24, 0x0259
     394:	88 23       	and	r24, r24
     396:	09 f0       	breq	.+2      	; 0x39a <dcf77_processTimeBuffer+0x26>
     398:	b6 c0       	rjmp	.+364    	; 0x506 <dcf77_processTimeBuffer+0x192>
		return;
     39a:	25 e1       	ldi	r18, 0x15	; 21
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	90 e0       	ldi	r25, 0x00	; 0
uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
		sum += m_dcf77_buffer[i];
     3a0:	f9 01       	movw	r30, r18
     3a2:	e7 5a       	subi	r30, 0xA7	; 167
     3a4:	fd 4f       	sbci	r31, 0xFD	; 253
     3a6:	80 81       	ld	r24, Z
     3a8:	98 0f       	add	r25, r24

uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
     3aa:	2f 5f       	subi	r18, 0xFF	; 255
     3ac:	3f 4f       	sbci	r19, 0xFF	; 255
     3ae:	2c 31       	cpi	r18, 0x1C	; 28
     3b0:	31 05       	cpc	r19, r1
     3b2:	b1 f7       	brne	.-20     	; 0x3a0 <dcf77_processTimeBuffer+0x2c>

	if (m_dcf77_buffer[0]!=0)	// 1. Bit muss 1 sein
		return;

	// check parity-bits:
	if (dcf77_getParityBit(21,27)!=m_dcf77_buffer[28])	// PB für Minuten falsch
     3b4:	50 91 75 02 	lds	r21, 0x0275
     3b8:	40 e0       	ldi	r20, 0x00	; 0
     3ba:	29 2f       	mov	r18, r25
     3bc:	30 e0       	ldi	r19, 0x00	; 0
     3be:	96 95       	lsr	r25
     3c0:	89 2f       	mov	r24, r25
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	28 17       	cp	r18, r24
     3ca:	39 07       	cpc	r19, r25
     3cc:	09 f0       	breq	.+2      	; 0x3d0 <dcf77_processTimeBuffer+0x5c>
     3ce:	41 e0       	ldi	r20, 0x01	; 1
     3d0:	45 17       	cp	r20, r21
     3d2:	09 f0       	breq	.+2      	; 0x3d6 <dcf77_processTimeBuffer+0x62>
     3d4:	98 c0       	rjmp	.+304    	; 0x506 <dcf77_processTimeBuffer+0x192>
uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
		sum += m_dcf77_buffer[i];
     3d6:	80 91 76 02 	lds	r24, 0x0276
     3da:	20 91 77 02 	lds	r18, 0x0277
     3de:	30 91 78 02 	lds	r19, 0x0278
     3e2:	40 91 79 02 	lds	r20, 0x0279
     3e6:	50 91 7a 02 	lds	r21, 0x027A
     3ea:	82 0f       	add	r24, r18
     3ec:	83 0f       	add	r24, r19
     3ee:	84 0f       	add	r24, r20
     3f0:	85 0f       	add	r24, r21
     3f2:	20 91 7b 02 	lds	r18, 0x027B
     3f6:	82 0f       	add	r24, r18
		return;

	// check parity-bits:
	if (dcf77_getParityBit(21,27)!=m_dcf77_buffer[28])	// PB für Minuten falsch
		return;
	if (dcf77_getParityBit(29,34)!=m_dcf77_buffer[35])	// PB für Stunden falsch
     3f8:	50 91 7c 02 	lds	r21, 0x027C
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	28 2f       	mov	r18, r24
     400:	30 e0       	ldi	r19, 0x00	; 0
     402:	86 95       	lsr	r24
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	88 0f       	add	r24, r24
     408:	99 1f       	adc	r25, r25
     40a:	28 17       	cp	r18, r24
     40c:	39 07       	cpc	r19, r25
     40e:	09 f0       	breq	.+2      	; 0x412 <dcf77_processTimeBuffer+0x9e>
     410:	41 e0       	ldi	r20, 0x01	; 1
     412:	45 17       	cp	r20, r21
     414:	09 f0       	breq	.+2      	; 0x418 <dcf77_processTimeBuffer+0xa4>
     416:	77 c0       	rjmp	.+238    	; 0x506 <dcf77_processTimeBuffer+0x192>
		return;
     418:	24 e2       	ldi	r18, 0x24	; 36
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	90 e0       	ldi	r25, 0x00	; 0
uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
		sum += m_dcf77_buffer[i];
     41e:	f9 01       	movw	r30, r18
     420:	e7 5a       	subi	r30, 0xA7	; 167
     422:	fd 4f       	sbci	r31, 0xFD	; 253
     424:	80 81       	ld	r24, Z
     426:	98 0f       	add	r25, r24

uint8_t dcf77_getParityBit(uint8_t start, uint8_t end)
{
//	char *buf = (char*)buffer;
	uint8_t sum=0;
	for (int i=start;i<=end;i++)
     428:	2f 5f       	subi	r18, 0xFF	; 255
     42a:	3f 4f       	sbci	r19, 0xFF	; 255
     42c:	2a 33       	cpi	r18, 0x3A	; 58
     42e:	31 05       	cpc	r19, r1
     430:	b1 f7       	brne	.-20     	; 0x41e <dcf77_processTimeBuffer+0xaa>
	// check parity-bits:
	if (dcf77_getParityBit(21,27)!=m_dcf77_buffer[28])	// PB für Minuten falsch
		return;
	if (dcf77_getParityBit(29,34)!=m_dcf77_buffer[35])	// PB für Stunden falsch
		return;
	if (dcf77_getParityBit(36,57)!=m_dcf77_buffer[58])	// PB für Datum falsch
     432:	50 91 93 02 	lds	r21, 0x0293
     436:	40 e0       	ldi	r20, 0x00	; 0
     438:	29 2f       	mov	r18, r25
     43a:	30 e0       	ldi	r19, 0x00	; 0
     43c:	96 95       	lsr	r25
     43e:	89 2f       	mov	r24, r25
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	88 0f       	add	r24, r24
     444:	99 1f       	adc	r25, r25
     446:	28 17       	cp	r18, r24
     448:	39 07       	cpc	r19, r25
     44a:	09 f0       	breq	.+2      	; 0x44e <dcf77_processTimeBuffer+0xda>
     44c:	41 e0       	ldi	r20, 0x01	; 1
     44e:	45 17       	cp	r20, r21
     450:	09 f0       	breq	.+2      	; 0x454 <dcf77_processTimeBuffer+0xe0>
     452:	59 c0       	rjmp	.+178    	; 0x506 <dcf77_processTimeBuffer+0x192>
		return;

	uint8_t h = m_dcf77_buffer[29] + m_dcf77_buffer[30]*2 + m_dcf77_buffer[31]*4 + m_dcf77_buffer[32]*8 
			+ m_dcf77_buffer[33]*10 + m_dcf77_buffer[34]*20;
     454:	e0 91 76 02 	lds	r30, 0x0276
     458:	20 91 7b 02 	lds	r18, 0x027B
     45c:	70 91 78 02 	lds	r23, 0x0278
     460:	80 91 79 02 	lds	r24, 0x0279
     464:	40 91 7a 02 	lds	r20, 0x027A
     468:	60 91 77 02 	lds	r22, 0x0277
     46c:	aa e0       	ldi	r26, 0x0A	; 10
     46e:	2a 9f       	mul	r18, r26
     470:	90 01       	movw	r18, r0
     472:	11 24       	eor	r1, r1
     474:	b5 e0       	ldi	r27, 0x05	; 5
     476:	4b 9f       	mul	r20, r27
     478:	a0 01       	movw	r20, r0
     47a:	11 24       	eor	r1, r1
     47c:	24 0f       	add	r18, r20
     47e:	35 1f       	adc	r19, r21
     480:	26 0f       	add	r18, r22
     482:	31 1d       	adc	r19, r1
     484:	90 e0       	ldi	r25, 0x00	; 0
     486:	88 0f       	add	r24, r24
     488:	99 1f       	adc	r25, r25
     48a:	87 0f       	add	r24, r23
     48c:	91 1d       	adc	r25, r1
     48e:	88 0f       	add	r24, r24
     490:	99 1f       	adc	r25, r25
     492:	28 0f       	add	r18, r24
     494:	39 1f       	adc	r19, r25
     496:	22 0f       	add	r18, r18
     498:	33 1f       	adc	r19, r19
     49a:	e2 0f       	add	r30, r18
	uint8_t m = m_dcf77_buffer[21] + m_dcf77_buffer[22]*2 + m_dcf77_buffer[23]*4 + m_dcf77_buffer[24]*8 
			  + m_dcf77_buffer[25]*10 + m_dcf77_buffer[26]*20 + m_dcf77_buffer[27]*40;
     49c:	f0 91 6e 02 	lds	r31, 0x026E
     4a0:	80 91 73 02 	lds	r24, 0x0273
     4a4:	90 91 74 02 	lds	r25, 0x0274
     4a8:	70 91 70 02 	lds	r23, 0x0270
     4ac:	60 91 71 02 	lds	r22, 0x0271
     4b0:	50 91 72 02 	lds	r21, 0x0272
     4b4:	40 91 6f 02 	lds	r20, 0x026F

	if (h>23 || m>59)
     4b8:	e8 31       	cpi	r30, 0x18	; 24
     4ba:	28 f5       	brcc	.+74     	; 0x506 <dcf77_processTimeBuffer+0x192>
		return;

	uint8_t h = m_dcf77_buffer[29] + m_dcf77_buffer[30]*2 + m_dcf77_buffer[31]*4 + m_dcf77_buffer[32]*8 
			+ m_dcf77_buffer[33]*10 + m_dcf77_buffer[34]*20;
	uint8_t m = m_dcf77_buffer[21] + m_dcf77_buffer[22]*2 + m_dcf77_buffer[23]*4 + m_dcf77_buffer[24]*8 
			  + m_dcf77_buffer[25]*10 + m_dcf77_buffer[26]*20 + m_dcf77_buffer[27]*40;
     4bc:	8a 9f       	mul	r24, r26
     4be:	90 01       	movw	r18, r0
     4c0:	11 24       	eor	r1, r1
     4c2:	84 e1       	ldi	r24, 0x14	; 20
     4c4:	98 9f       	mul	r25, r24
     4c6:	c0 01       	movw	r24, r0
     4c8:	11 24       	eor	r1, r1
     4ca:	28 0f       	add	r18, r24
     4cc:	39 1f       	adc	r19, r25
     4ce:	24 0f       	add	r18, r20
     4d0:	31 1d       	adc	r19, r1
     4d2:	5b 9f       	mul	r21, r27
     4d4:	c0 01       	movw	r24, r0
     4d6:	11 24       	eor	r1, r1
     4d8:	28 0f       	add	r18, r24
     4da:	39 1f       	adc	r19, r25
     4dc:	86 2f       	mov	r24, r22
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	88 0f       	add	r24, r24
     4e2:	99 1f       	adc	r25, r25
     4e4:	87 0f       	add	r24, r23
     4e6:	91 1d       	adc	r25, r1
     4e8:	88 0f       	add	r24, r24
     4ea:	99 1f       	adc	r25, r25
     4ec:	28 0f       	add	r18, r24
     4ee:	39 1f       	adc	r19, r25
     4f0:	22 0f       	add	r18, r18
     4f2:	33 1f       	adc	r19, r19
     4f4:	8f 2f       	mov	r24, r31
     4f6:	82 0f       	add	r24, r18

	if (h>23 || m>59)
     4f8:	8c 33       	cpi	r24, 0x3C	; 60
     4fa:	28 f4       	brcc	.+10     	; 0x506 <dcf77_processTimeBuffer+0x192>
		return;
	
	*hr=h;
     4fc:	e8 83       	st	Y, r30
	*min=m;
     4fe:	f8 01       	movw	r30, r16
     500:	80 83       	st	Z, r24
	*sec=0;
     502:	f7 01       	movw	r30, r14
     504:	10 82       	st	Z, r1

}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	08 95       	ret

00000514 <dcf77_processBit>:
#include "dcf77.h"
#include "ledText.h"

void dcf77_processBit(uint8_t inp, uint8_t *hr, uint8_t *min, uint8_t *sec, int *ms)
{
     514:	0f 93       	push	r16
     516:	1f 93       	push	r17
     518:	e8 2f       	mov	r30, r24
     51a:	d8 01       	movw	r26, r16
	m_dcf77_t10ms_counter++; 	// counter incrementieren
     51c:	80 91 56 02 	lds	r24, 0x0256
     520:	90 91 57 02 	lds	r25, 0x0257
     524:	01 96       	adiw	r24, 0x01	; 1
     526:	90 93 57 02 	sts	0x0257, r25
     52a:	80 93 56 02 	sts	0x0256, r24

	if (!m_dcf77_validData && !m_dcf77_pin_up && !inp)	// Signal noch nicht synchronisiert. Warte auf 59. Bit
     52e:	80 91 55 02 	lds	r24, 0x0255
     532:	88 23       	and	r24, r24
     534:	a1 f4       	brne	.+40     	; 0x55e <dcf77_processBit+0x4a>
     536:	80 91 58 02 	lds	r24, 0x0258
     53a:	88 23       	and	r24, r24
     53c:	81 f4       	brne	.+32     	; 0x55e <dcf77_processBit+0x4a>
     53e:	ee 23       	and	r30, r30
     540:	71 f4       	brne	.+28     	; 0x55e <dcf77_processBit+0x4a>
	{
			if (m_dcf77_t10ms_counter > 1000)	// > 1 Sekunde = Ende der Sequenz
     542:	80 91 56 02 	lds	r24, 0x0256
     546:	90 91 57 02 	lds	r25, 0x0257
     54a:	89 5e       	subi	r24, 0xE9	; 233
     54c:	93 40       	sbci	r25, 0x03	; 3
     54e:	38 f0       	brcs	.+14     	; 0x55e <dcf77_processBit+0x4a>
			{
				m_dcf77_validData=1;
     550:	81 e0       	ldi	r24, 0x01	; 1
     552:	80 93 55 02 	sts	0x0255, r24
				m_dcf77_buffer_index=0;
     556:	10 92 95 02 	sts	0x0295, r1
				m_dcf77_gotLastBit=1;
     55a:	80 93 96 02 	sts	0x0296, r24
			}
	}

	if (m_dcf77_pin_up && !inp)		// Signal hat auf low gewechselt
     55e:	80 91 58 02 	lds	r24, 0x0258
     562:	88 23       	and	r24, r24
     564:	a1 f1       	breq	.+104    	; 0x5ce <dcf77_processBit+0xba>
     566:	ee 23       	and	r30, r30
     568:	91 f5       	brne	.+100    	; 0x5ce <dcf77_processBit+0xba>
	{
		m_dcf77_pin_up=0;
     56a:	10 92 58 02 	sts	0x0258, r1

		if (m_dcf77_validData)
     56e:	80 91 55 02 	lds	r24, 0x0255
     572:	88 23       	and	r24, r24
     574:	09 f4       	brne	.+2      	; 0x578 <dcf77_processBit+0x64>
     576:	41 c0       	rjmp	.+130    	; 0x5fa <dcf77_processBit+0xe6>
		{
			if (m_dcf77_t10ms_counter < 40)
     578:	80 91 56 02 	lds	r24, 0x0256
     57c:	90 91 57 02 	lds	r25, 0x0257
     580:	88 97       	sbiw	r24, 0x28	; 40
     582:	18 f4       	brcc	.+6      	; 0x58a <dcf77_processBit+0x76>
			{
				m_dcf77_validData=0;
     584:	10 92 55 02 	sts	0x0255, r1
     588:	15 c0       	rjmp	.+42     	; 0x5b4 <dcf77_processBit+0xa0>
			}
			else
				if (m_dcf77_t10ms_counter >= 150)
     58a:	80 91 56 02 	lds	r24, 0x0256
     58e:	90 91 57 02 	lds	r25, 0x0257
     592:	86 39       	cpi	r24, 0x96	; 150
     594:	91 05       	cpc	r25, r1
     596:	40 f0       	brcs	.+16     	; 0x5a8 <dcf77_processBit+0x94>
				m_dcf77_buffer[m_dcf77_buffer_index]=1;
     598:	e0 91 95 02 	lds	r30, 0x0295
     59c:	f0 e0       	ldi	r31, 0x00	; 0
     59e:	e7 5a       	subi	r30, 0xA7	; 167
     5a0:	fd 4f       	sbci	r31, 0xFD	; 253
     5a2:	81 e0       	ldi	r24, 0x01	; 1
     5a4:	80 83       	st	Z, r24
     5a6:	06 c0       	rjmp	.+12     	; 0x5b4 <dcf77_processBit+0xa0>
			else
				m_dcf77_buffer[m_dcf77_buffer_index]=0;
     5a8:	e0 91 95 02 	lds	r30, 0x0295
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	e7 5a       	subi	r30, 0xA7	; 167
     5b0:	fd 4f       	sbci	r31, 0xFD	; 253
     5b2:	10 82       	st	Z, r1
		
			if (m_dcf77_buffer_index>=58)
     5b4:	80 91 95 02 	lds	r24, 0x0295
     5b8:	8a 33       	cpi	r24, 0x3A	; 58
     5ba:	18 f0       	brcs	.+6      	; 0x5c2 <dcf77_processBit+0xae>
			{
				m_dcf77_validData=0;				// Sequenz beendet
     5bc:	10 92 55 02 	sts	0x0255, r1
     5c0:	1c c0       	rjmp	.+56     	; 0x5fa <dcf77_processBit+0xe6>
			}
			else
				m_dcf77_buffer_index++;
     5c2:	80 91 95 02 	lds	r24, 0x0295
     5c6:	8f 5f       	subi	r24, 0xFF	; 255
     5c8:	80 93 95 02 	sts	0x0295, r24
     5cc:	16 c0       	rjmp	.+44     	; 0x5fa <dcf77_processBit+0xe6>
		}
		m_dcf77_t10ms_counter=0;
	} 
	else if (!m_dcf77_pin_up && inp)
     5ce:	80 91 58 02 	lds	r24, 0x0258
     5d2:	88 23       	and	r24, r24
     5d4:	b1 f4       	brne	.+44     	; 0x602 <dcf77_processBit+0xee>
     5d6:	ee 23       	and	r30, r30
     5d8:	a1 f0       	breq	.+40     	; 0x602 <dcf77_processBit+0xee>
	{
		if (m_dcf77_gotLastBit)
     5da:	80 91 96 02 	lds	r24, 0x0296
     5de:	88 23       	and	r24, r24
     5e0:	49 f0       	breq	.+18     	; 0x5f4 <dcf77_processBit+0xe0>
		{
			*ms=0;
     5e2:	1d 92       	st	X+, r1
     5e4:	1c 92       	st	X, r1
			dcf77_processTimeBuffer(hr, min, sec);
     5e6:	cb 01       	movw	r24, r22
     5e8:	ba 01       	movw	r22, r20
     5ea:	a9 01       	movw	r20, r18
     5ec:	0e 94 ba 01 	call	0x374	; 0x374 <dcf77_processTimeBuffer>
			m_dcf77_gotLastBit=0;
     5f0:	10 92 96 02 	sts	0x0296, r1

		/*DEBUG!!*/
		}


		m_dcf77_pin_up=1;
     5f4:	81 e0       	ldi	r24, 0x01	; 1
     5f6:	80 93 58 02 	sts	0x0258, r24
		m_dcf77_t10ms_counter=0;
     5fa:	10 92 57 02 	sts	0x0257, r1
     5fe:	10 92 56 02 	sts	0x0256, r1

	}

}
     602:	1f 91       	pop	r17
     604:	0f 91       	pop	r16
     606:	08 95       	ret

00000608 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
     608:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     60a:	f9 99       	sbic	0x1f, 1	; 31
     60c:	fe cf       	rjmp	.-4      	; 0x60a <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     60e:	32 bd       	out	0x22, r19	; 34
     610:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     612:	f8 9a       	sbi	0x1f, 0	; 31
     614:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     616:	08 95       	ret

00000618 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     618:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     61a:	f9 99       	sbic	0x1f, 1	; 31
     61c:	fe cf       	rjmp	.-4      	; 0x61a <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     61e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     620:	32 bd       	out	0x22, r19	; 34
     622:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     624:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
     626:	0f b6       	in	r0, 0x3f	; 63
     628:	f8 94       	cli
     62a:	fa 9a       	sbi	0x1f, 2	; 31
     62c:	f9 9a       	sbi	0x1f, 1	; 31
     62e:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     630:	08 95       	ret

00000632 <setTextId>:
static volatile char *activeString;
static volatile uint8_t ledText_newTextId;

void setTextId(uint8_t id)
{
	ledText_newTextId=id;
     632:	80 93 c4 03 	sts	0x03C4, r24
}
     636:	08 95       	ret

00000638 <ledText_beginSequence>:
	ledText_beginSequence();
}

void ledText_beginSequence()
{
	if (ledText_tickCounter < 50)
     638:	80 91 97 02 	lds	r24, 0x0297
     63c:	90 91 98 02 	lds	r25, 0x0298
     640:	c2 97       	sbiw	r24, 0x32	; 50
     642:	08 f4       	brcc	.+2      	; 0x646 <ledText_beginSequence+0xe>
     644:	46 c0       	rjmp	.+140    	; 0x6d2 <ledText_beginSequence+0x9a>
		return;


	// Prüfen, ob Text ausgetauscht werden soll
	if (activeText!=&ledText[ledText_newTextId])
     646:	80 91 c4 03 	lds	r24, 0x03C4
     64a:	4b e0       	ldi	r20, 0x0B	; 11
     64c:	84 9f       	mul	r24, r20
     64e:	c0 01       	movw	r24, r0
     650:	11 24       	eor	r1, r1
     652:	8e 55       	subi	r24, 0x5E	; 94
     654:	9d 4f       	sbci	r25, 0xFD	; 253
     656:	20 91 c0 03 	lds	r18, 0x03C0
     65a:	30 91 c1 03 	lds	r19, 0x03C1
     65e:	28 17       	cp	r18, r24
     660:	39 07       	cpc	r19, r25
     662:	09 f1       	breq	.+66     	; 0x6a6 <ledText_beginSequence+0x6e>
	{
		activeText=&ledText[ledText_newTextId];
     664:	80 91 c4 03 	lds	r24, 0x03C4
     668:	84 9f       	mul	r24, r20
     66a:	c0 01       	movw	r24, r0
     66c:	11 24       	eor	r1, r1
     66e:	8e 55       	subi	r24, 0x5E	; 94
     670:	9d 4f       	sbci	r25, 0xFD	; 253
     672:	90 93 c1 03 	sts	0x03C1, r25
     676:	80 93 c0 03 	sts	0x03C0, r24
		switch (ledText_newTextId)
     67a:	80 91 c4 03 	lds	r24, 0x03C4
     67e:	88 23       	and	r24, r24
     680:	19 f0       	breq	.+6      	; 0x688 <ledText_beginSequence+0x50>
     682:	81 30       	cpi	r24, 0x01	; 1
     684:	51 f4       	brne	.+20     	; 0x69a <ledText_beginSequence+0x62>
     686:	03 c0       	rjmp	.+6      	; 0x68e <ledText_beginSequence+0x56>
		{
			case 0: activeString = ledText_time; break;
     688:	88 eb       	ldi	r24, 0xB8	; 184
     68a:	92 e0       	ldi	r25, 0x02	; 2
     68c:	02 c0       	rjmp	.+4      	; 0x692 <ledText_beginSequence+0x5a>
			case 1: activeString = ledText_customString; break;
     68e:	81 ec       	ldi	r24, 0xC1	; 193
     690:	92 e0       	ldi	r25, 0x02	; 2
     692:	90 93 c3 03 	sts	0x03C3, r25
     696:	80 93 c2 03 	sts	0x03C2, r24
		}

		ledText_firstCharIndex=0;
     69a:	10 92 a0 02 	sts	0x02A0, r1
		ledText_firstCharSubIndex=0;
     69e:	10 92 a1 02 	sts	0x02A1, r1
		ledText_seqCounter=0;
     6a2:	10 92 9b 02 	sts	0x029B, r1
	}

	// Sequenz bei 0 starten
	ledText_tickCounter=0;
     6a6:	10 92 98 02 	sts	0x0298, r1
     6aa:	10 92 97 02 	sts	0x0297, r1
	ledText_tickCounter_on=(*activeText).ticksBetween;
     6ae:	e0 91 c0 03 	lds	r30, 0x03C0
     6b2:	f0 91 c1 03 	lds	r31, 0x03C1
     6b6:	84 81       	ldd	r24, Z+4	; 0x04
     6b8:	80 93 99 02 	sts	0x0299, r24
	ledText_tickCounter_space=(*activeText).charSpace;
     6bc:	81 85       	ldd	r24, Z+9	; 0x09
     6be:	80 93 9a 02 	sts	0x029A, r24
		}
	}
	else
		ledText_seqCounter++;
*/
	ledText_charIndex=ledText_firstCharIndex;
     6c2:	80 91 a0 02 	lds	r24, 0x02A0
     6c6:	80 93 9e 02 	sts	0x029E, r24
	ledText_charSubIndex=ledText_firstCharSubIndex;
     6ca:	80 91 a1 02 	lds	r24, 0x02A1
     6ce:	80 93 9f 02 	sts	0x029F, r24
     6d2:	08 95       	ret

000006d4 <swapByte>:

}

char swapByte(char c)
{
     6d4:	50 e0       	ldi	r21, 0x00	; 0
     6d6:	47 e0       	ldi	r20, 0x07	; 7
     6d8:	20 e0       	ldi	r18, 0x00	; 0
     6da:	30 e0       	ldi	r19, 0x00	; 0
	char c2=0;
	uint8_t i,j;
	for (i=0,j=7;i<8;i++,j--)
		c2 |= ((c & (1<<j)) >> j) << i;
     6dc:	e1 e0       	ldi	r30, 0x01	; 1
     6de:	f0 e0       	ldi	r31, 0x00	; 0
     6e0:	68 2f       	mov	r22, r24
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	cf 01       	movw	r24, r30
     6e6:	04 2e       	mov	r0, r20
     6e8:	02 c0       	rjmp	.+4      	; 0x6ee <swapByte+0x1a>
     6ea:	88 0f       	add	r24, r24
     6ec:	99 1f       	adc	r25, r25
     6ee:	0a 94       	dec	r0
     6f0:	e2 f7       	brpl	.-8      	; 0x6ea <swapByte+0x16>
     6f2:	86 23       	and	r24, r22
     6f4:	97 23       	and	r25, r23
     6f6:	04 2e       	mov	r0, r20
     6f8:	02 c0       	rjmp	.+4      	; 0x6fe <swapByte+0x2a>
     6fa:	95 95       	asr	r25
     6fc:	87 95       	ror	r24
     6fe:	0a 94       	dec	r0
     700:	e2 f7       	brpl	.-8      	; 0x6fa <swapByte+0x26>
     702:	02 2e       	mov	r0, r18
     704:	02 c0       	rjmp	.+4      	; 0x70a <swapByte+0x36>
     706:	88 0f       	add	r24, r24
     708:	99 1f       	adc	r25, r25
     70a:	0a 94       	dec	r0
     70c:	e2 f7       	brpl	.-8      	; 0x706 <swapByte+0x32>
     70e:	58 2b       	or	r21, r24

char swapByte(char c)
{
	char c2=0;
	uint8_t i,j;
	for (i=0,j=7;i<8;i++,j--)
     710:	41 50       	subi	r20, 0x01	; 1
     712:	2f 5f       	subi	r18, 0xFF	; 255
     714:	3f 4f       	sbci	r19, 0xFF	; 255
     716:	4f 3f       	cpi	r20, 0xFF	; 255
     718:	29 f7       	brne	.-54     	; 0x6e4 <swapByte+0x10>
		c2 |= ((c & (1<<j)) >> j) << i;

	return c2;
}
     71a:	85 2f       	mov	r24, r21
     71c:	08 95       	ret

0000071e <ledText_setPort>:

void ledText_setPort(uint8_t val)
{
	PORTC=(val & 0b00111111);
     71e:	98 2f       	mov	r25, r24
     720:	9f 73       	andi	r25, 0x3F	; 63
     722:	98 b9       	out	0x08, r25	; 8
	PORTD&=0b00111111;	// Bit 6 und 7 löschen
     724:	9b b1       	in	r25, 0x0b	; 11
     726:	9f 73       	andi	r25, 0x3F	; 63
     728:	9b b9       	out	0x0b, r25	; 11
	PORTD|=(val & 0b11000000); // Bit 6 und 7 setzen
     72a:	9b b1       	in	r25, 0x0b	; 11
     72c:	80 7c       	andi	r24, 0xC0	; 192
     72e:	98 2b       	or	r25, r24
     730:	9b b9       	out	0x0b, r25	; 11
}
     732:	08 95       	ret

00000734 <ledText_tick>:

void ledText_tick()
{
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
	if ((*activeText).ticksPerScroll>0)
     738:	c0 91 c0 03 	lds	r28, 0x03C0
     73c:	d0 91 c1 03 	lds	r29, 0x03C1
     740:	8d 81       	ldd	r24, Y+5	; 0x05
     742:	9e 81       	ldd	r25, Y+6	; 0x06
     744:	89 2b       	or	r24, r25
     746:	09 f4       	brne	.+2      	; 0x74a <ledText_tick+0x16>
     748:	49 c0       	rjmp	.+146    	; 0x7dc <ledText_tick+0xa8>
	{
		if (ledText_scrollTicks>(*activeText).ticksPerScroll)
     74a:	20 91 9c 02 	lds	r18, 0x029C
     74e:	30 91 9d 02 	lds	r19, 0x029D
     752:	8d 81       	ldd	r24, Y+5	; 0x05
     754:	9e 81       	ldd	r25, Y+6	; 0x06
     756:	82 17       	cp	r24, r18
     758:	93 07       	cpc	r25, r19
     75a:	b8 f5       	brcc	.+110    	; 0x7ca <ledText_tick+0x96>
		{
			ledText_scrollTicks=0;
     75c:	10 92 9d 02 	sts	0x029D, r1
     760:	10 92 9c 02 	sts	0x029C, r1

			ledText_firstCharSubIndex += (*activeText).scrollSpeed;
     764:	90 91 a1 02 	lds	r25, 0x02A1
     768:	8f 81       	ldd	r24, Y+7	; 0x07
     76a:	89 0f       	add	r24, r25
     76c:	80 93 a1 02 	sts	0x02A1, r24
			while (ledText_firstCharSubIndex >= (*activeText).charWidth)
			{
				ledText_firstCharSubIndex-=(*activeText).charWidth;
				if (ledText_firstCharIndex>=strlen((char*)activeString)-1)
     770:	30 91 c2 03 	lds	r19, 0x03C2
     774:	20 91 c3 03 	lds	r18, 0x03C3
     778:	1d c0       	rjmp	.+58     	; 0x7b4 <ledText_tick+0x80>
			ledText_scrollTicks=0;

			ledText_firstCharSubIndex += (*activeText).scrollSpeed;
			while (ledText_firstCharSubIndex >= (*activeText).charWidth)
			{
				ledText_firstCharSubIndex-=(*activeText).charWidth;
     77a:	80 91 a1 02 	lds	r24, 0x02A1
     77e:	98 85       	ldd	r25, Y+8	; 0x08
     780:	89 1b       	sub	r24, r25
     782:	80 93 a1 02 	sts	0x02A1, r24
				if (ledText_firstCharIndex>=strlen((char*)activeString)-1)
     786:	80 91 a0 02 	lds	r24, 0x02A0
     78a:	e3 2f       	mov	r30, r19
     78c:	f2 2f       	mov	r31, r18
     78e:	df 01       	movw	r26, r30
     790:	0d 90       	ld	r0, X+
     792:	00 20       	and	r0, r0
     794:	e9 f7       	brne	.-6      	; 0x790 <ledText_tick+0x5c>
     796:	ae 1b       	sub	r26, r30
     798:	bf 0b       	sbc	r27, r31
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	12 97       	sbiw	r26, 0x02	; 2
     79e:	8a 17       	cp	r24, r26
     7a0:	9b 07       	cpc	r25, r27
     7a2:	18 f0       	brcs	.+6      	; 0x7aa <ledText_tick+0x76>
					ledText_firstCharIndex=0;
     7a4:	10 92 a0 02 	sts	0x02A0, r1
     7a8:	05 c0       	rjmp	.+10     	; 0x7b4 <ledText_tick+0x80>
				else
					ledText_firstCharIndex++;
     7aa:	80 91 a0 02 	lds	r24, 0x02A0
     7ae:	8f 5f       	subi	r24, 0xFF	; 255
     7b0:	80 93 a0 02 	sts	0x02A0, r24
		if (ledText_scrollTicks>(*activeText).ticksPerScroll)
		{
			ledText_scrollTicks=0;

			ledText_firstCharSubIndex += (*activeText).scrollSpeed;
			while (ledText_firstCharSubIndex >= (*activeText).charWidth)
     7b4:	90 91 a1 02 	lds	r25, 0x02A1
     7b8:	88 85       	ldd	r24, Y+8	; 0x08
     7ba:	98 17       	cp	r25, r24
     7bc:	f0 f6       	brcc	.-68     	; 0x77a <ledText_tick+0x46>
					ledText_firstCharIndex=0;
				else
					ledText_firstCharIndex++;
			}
*/			
			ledText_charSubIndex++;
     7be:	80 91 9f 02 	lds	r24, 0x029F
     7c2:	8f 5f       	subi	r24, 0xFF	; 255
     7c4:	80 93 9f 02 	sts	0x029F, r24
     7c8:	09 c0       	rjmp	.+18     	; 0x7dc <ledText_tick+0xa8>
		}
		else
			ledText_scrollTicks++;
     7ca:	80 91 9c 02 	lds	r24, 0x029C
     7ce:	90 91 9d 02 	lds	r25, 0x029D
     7d2:	01 96       	adiw	r24, 0x01	; 1
     7d4:	90 93 9d 02 	sts	0x029D, r25
     7d8:	80 93 9c 02 	sts	0x029C, r24
	}


	if (ledText_tickCounter>=(*activeText).ticks2Begin && ledText_tickCounter<=(*activeText).ticks2End)
     7dc:	20 91 97 02 	lds	r18, 0x0297
     7e0:	30 91 98 02 	lds	r19, 0x0298
     7e4:	88 81       	ld	r24, Y
     7e6:	99 81       	ldd	r25, Y+1	; 0x01
     7e8:	28 17       	cp	r18, r24
     7ea:	39 07       	cpc	r19, r25
     7ec:	08 f4       	brcc	.+2      	; 0x7f0 <ledText_tick+0xbc>
     7ee:	90 c0       	rjmp	.+288    	; 0x910 <__stack+0x11>
     7f0:	20 91 97 02 	lds	r18, 0x0297
     7f4:	30 91 98 02 	lds	r19, 0x0298
     7f8:	8a 81       	ldd	r24, Y+2	; 0x02
     7fa:	9b 81       	ldd	r25, Y+3	; 0x03
     7fc:	82 17       	cp	r24, r18
     7fe:	93 07       	cpc	r25, r19
     800:	08 f4       	brcc	.+2      	; 0x804 <ledText_tick+0xd0>
     802:	86 c0       	rjmp	.+268    	; 0x910 <__stack+0x11>
	{
		// in dieser Lücke darf Text angezeigt werden
		if (ledText_tickCounter_on>(*activeText).ticksBetween)
     804:	90 91 99 02 	lds	r25, 0x0299
     808:	8c 81       	ldd	r24, Y+4	; 0x04
     80a:	89 17       	cp	r24, r25
     80c:	08 f0       	brcs	.+2      	; 0x810 <ledText_tick+0xdc>
     80e:	86 c0       	rjmp	.+268    	; 0x91c <__stack+0x1d>
	return c2;
}

void ledText_setPort(uint8_t val)
{
	PORTC=(val & 0b00111111);
     810:	18 b8       	out	0x08, r1	; 8
	PORTD&=0b00111111;	// Bit 6 und 7 löschen
     812:	8b b1       	in	r24, 0x0b	; 11
     814:	8f 73       	andi	r24, 0x3F	; 63
     816:	8b b9       	out	0x0b, r24	; 11
	PORTD|=(val & 0b11000000); // Bit 6 und 7 setzen
     818:	8b b1       	in	r24, 0x0b	; 11
     81a:	8b b9       	out	0x0b, r24	; 11
	{
		// in dieser Lücke darf Text angezeigt werden
		if (ledText_tickCounter_on>(*activeText).ticksBetween)
		{
			ledText_setPort(0);
			if (ledText_tickCounter_space>(*activeText).charSpace)
     81c:	90 91 9a 02 	lds	r25, 0x029A
     820:	89 85       	ldd	r24, Y+9	; 0x09
     822:	89 17       	cp	r24, r25
     824:	08 f0       	brcs	.+2      	; 0x828 <ledText_tick+0xf4>
     826:	68 c0       	rjmp	.+208    	; 0x8f8 <ledText_tick+0x1c4>
			{
				if (ledText_charSubIndex<(*activeText).charWidth)
     828:	90 91 9f 02 	lds	r25, 0x029F
     82c:	88 85       	ldd	r24, Y+8	; 0x08
     82e:	98 17       	cp	r25, r24
     830:	e0 f5       	brcc	.+120    	; 0x8aa <ledText_tick+0x176>
				{
					// LEDs dürfen geändert werden
					char c=activeString[ledText_charIndex];
     832:	80 91 9e 02 	lds	r24, 0x029E
     836:	e0 91 c2 03 	lds	r30, 0x03C2
     83a:	f0 91 c3 03 	lds	r31, 0x03C3
     83e:	e8 0f       	add	r30, r24
     840:	f1 1d       	adc	r31, r1
     842:	e0 81       	ld	r30, Z
					if (c>='a' && c<='z') c-=32;	// 'a' -> 'A'
     844:	8e 2f       	mov	r24, r30
     846:	81 56       	subi	r24, 0x61	; 97
     848:	8a 31       	cpi	r24, 0x1A	; 26
     84a:	08 f4       	brcc	.+2      	; 0x84e <ledText_tick+0x11a>
     84c:	e0 52       	subi	r30, 0x20	; 32
					if (c>=' ' && c<='_')
     84e:	8e 2f       	mov	r24, r30
     850:	80 52       	subi	r24, 0x20	; 32
     852:	80 34       	cpi	r24, 0x40	; 64
     854:	e0 f4       	brcc	.+56     	; 0x88e <ledText_tick+0x15a>
						ledText_setPort(matrixASCII[c-' '][ledText_charSubIndex]);
     856:	20 91 9f 02 	lds	r18, 0x029F
     85a:	8e 2f       	mov	r24, r30
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	80 97       	sbiw	r24, 0x20	; 32
     860:	fc 01       	movw	r30, r24
     862:	ee 0f       	add	r30, r30
     864:	ff 1f       	adc	r31, r31
     866:	ee 0f       	add	r30, r30
     868:	ff 1f       	adc	r31, r31
     86a:	e8 0f       	add	r30, r24
     86c:	f9 1f       	adc	r31, r25
     86e:	e2 0f       	add	r30, r18
     870:	f1 1d       	adc	r31, r1
     872:	e1 5f       	subi	r30, 0xF1	; 241
     874:	fe 4f       	sbci	r31, 0xFE	; 254
     876:	90 81       	ld	r25, Z
	return c2;
}

void ledText_setPort(uint8_t val)
{
	PORTC=(val & 0b00111111);
     878:	89 2f       	mov	r24, r25
     87a:	8f 73       	andi	r24, 0x3F	; 63
     87c:	88 b9       	out	0x08, r24	; 8
	PORTD&=0b00111111;	// Bit 6 und 7 löschen
     87e:	8b b1       	in	r24, 0x0b	; 11
     880:	8f 73       	andi	r24, 0x3F	; 63
     882:	8b b9       	out	0x0b, r24	; 11
	PORTD|=(val & 0b11000000); // Bit 6 und 7 setzen
     884:	8b b1       	in	r24, 0x0b	; 11
     886:	90 7c       	andi	r25, 0xC0	; 192
     888:	98 2b       	or	r25, r24
     88a:	9b b9       	out	0x0b, r25	; 11
     88c:	06 c0       	rjmp	.+12     	; 0x89a <ledText_tick+0x166>
	return c2;
}

void ledText_setPort(uint8_t val)
{
	PORTC=(val & 0b00111111);
     88e:	18 b8       	out	0x08, r1	; 8
	PORTD&=0b00111111;	// Bit 6 und 7 löschen
     890:	8b b1       	in	r24, 0x0b	; 11
     892:	8f 73       	andi	r24, 0x3F	; 63
     894:	8b b9       	out	0x0b, r24	; 11
	PORTD|=(val & 0b11000000); // Bit 6 und 7 setzen
     896:	8b b1       	in	r24, 0x0b	; 11
     898:	8b b9       	out	0x0b, r24	; 11
					if (c>=' ' && c<='_')
						ledText_setPort(matrixASCII[c-' '][ledText_charSubIndex]);
					else
						ledText_setPort(0);

					ledText_charSubIndex++;
     89a:	80 91 9f 02 	lds	r24, 0x029F
     89e:	8f 5f       	subi	r24, 0xFF	; 255
     8a0:	80 93 9f 02 	sts	0x029F, r24
					ledText_tickCounter_on=0;
     8a4:	10 92 99 02 	sts	0x0299, r1
     8a8:	39 c0       	rjmp	.+114    	; 0x91c <__stack+0x1d>
				} 
				else 
				{
					ledText_charSubIndex=0;
     8aa:	10 92 9f 02 	sts	0x029F, r1
					if (ledText_charIndex>=strlen((char*)activeString)-1)
     8ae:	80 91 9e 02 	lds	r24, 0x029E
     8b2:	e0 91 c2 03 	lds	r30, 0x03C2
     8b6:	f0 91 c3 03 	lds	r31, 0x03C3
     8ba:	df 01       	movw	r26, r30
     8bc:	0d 90       	ld	r0, X+
     8be:	00 20       	and	r0, r0
     8c0:	e9 f7       	brne	.-6      	; 0x8bc <ledText_tick+0x188>
     8c2:	11 97       	sbiw	r26, 0x01	; 1
     8c4:	ae 1b       	sub	r26, r30
     8c6:	bf 0b       	sbc	r27, r31
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	9d 01       	movw	r18, r26
     8cc:	21 50       	subi	r18, 0x01	; 1
     8ce:	30 40       	sbci	r19, 0x00	; 0
     8d0:	82 17       	cp	r24, r18
     8d2:	93 07       	cpc	r25, r19
     8d4:	48 f0       	brcs	.+18     	; 0x8e8 <ledText_tick+0x1b4>
					{
						// Text wurde vollständig ausgegeben

						if ((*activeText).repeat==1)
     8d6:	8a 85       	ldd	r24, Y+10	; 0x0a
     8d8:	81 30       	cpi	r24, 0x01	; 1
     8da:	19 f4       	brne	.+6      	; 0x8e2 <ledText_tick+0x1ae>
						{	
							// Text wiederholen
							ledText_charIndex=0;
     8dc:	10 92 9e 02 	sts	0x029E, r1
     8e0:	08 c0       	rjmp	.+16     	; 0x8f2 <ledText_tick+0x1be>
						}
						else 
							ledText_charIndex=strlen((char*)activeString);
     8e2:	a0 93 9e 02 	sts	0x029E, r26
     8e6:	05 c0       	rjmp	.+10     	; 0x8f2 <ledText_tick+0x1be>
					} else
						ledText_charIndex++;
     8e8:	80 91 9e 02 	lds	r24, 0x029E
     8ec:	8f 5f       	subi	r24, 0xFF	; 255
     8ee:	80 93 9e 02 	sts	0x029E, r24
						
					ledText_tickCounter_space=0;	// Abstand zwischen Zeichen einbauen
     8f2:	10 92 9a 02 	sts	0x029A, r1
     8f6:	12 c0       	rjmp	.+36     	; 0x91c <__stack+0x1d>
	return c2;
}

void ledText_setPort(uint8_t val)
{
	PORTC=(val & 0b00111111);
     8f8:	18 b8       	out	0x08, r1	; 8
	PORTD&=0b00111111;	// Bit 6 und 7 löschen
     8fa:	8b b1       	in	r24, 0x0b	; 11
     8fc:	8f 73       	andi	r24, 0x3F	; 63
     8fe:	8b b9       	out	0x0b, r24	; 11
	PORTD|=(val & 0b11000000); // Bit 6 und 7 setzen
     900:	8b b1       	in	r24, 0x0b	; 11
     902:	8b b9       	out	0x0b, r24	; 11


			} else
			{
				ledText_setPort(0);
				ledText_tickCounter_space++;
     904:	80 91 9a 02 	lds	r24, 0x029A
     908:	8f 5f       	subi	r24, 0xFF	; 255
     90a:	80 93 9a 02 	sts	0x029A, r24
     90e:	06 c0       	rjmp	.+12     	; 0x91c <__stack+0x1d>
	return c2;
}

void ledText_setPort(uint8_t val)
{
	PORTC=(val & 0b00111111);
     910:	18 b8       	out	0x08, r1	; 8
	PORTD&=0b00111111;	// Bit 6 und 7 löschen
     912:	8b b1       	in	r24, 0x0b	; 11
     914:	8f 73       	andi	r24, 0x3F	; 63
     916:	8b b9       	out	0x0b, r24	; 11
	PORTD|=(val & 0b11000000); // Bit 6 und 7 setzen
     918:	8b b1       	in	r24, 0x0b	; 11
     91a:	8b b9       	out	0x0b, r24	; 11
	else
	{
		ledText_setPort(0);
	}

	ledText_tickCounter++;
     91c:	80 91 97 02 	lds	r24, 0x0297
     920:	90 91 98 02 	lds	r25, 0x0298
     924:	01 96       	adiw	r24, 0x01	; 1
     926:	90 93 98 02 	sts	0x0298, r25
     92a:	80 93 97 02 	sts	0x0297, r24
	ledText_tickCounter_on++;
     92e:	80 91 99 02 	lds	r24, 0x0299
     932:	8f 5f       	subi	r24, 0xFF	; 255
     934:	80 93 99 02 	sts	0x0299, r24

//	if (ledText_tickCounter>(*activeText).ticks2End) //LEDTEXT_TICKS_TO_END)
//		ledText_beginSequence(); // DEBUG!! 
}
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	08 95       	ret

0000093e <ledText_init>:
{
	eeprom_write_block((const void*)&ledText_customString, (void*)&EE_ledText_CustomString, 255);
}

void ledText_init()
{
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
     942:	82 ea       	ldi	r24, 0xA2	; 162
     944:	92 e0       	ldi	r25, 0x02	; 2
     946:	6b e0       	ldi	r22, 0x0B	; 11
     948:	70 e0       	ldi	r23, 0x00	; 0
     94a:	4b e0       	ldi	r20, 0x0B	; 11
     94c:	50 e0       	ldi	r21, 0x00	; 0
     94e:	24 e0       	ldi	r18, 0x04	; 4
     950:	33 e0       	ldi	r19, 0x03	; 3
     952:	0e 94 2a 06 	call	0xc54	; 0xc54 <__eerd_block>
static volatile char *activeString;
static volatile uint8_t ledText_newTextId;

void setTextId(uint8_t id)
{
	ledText_newTextId=id;
     956:	8d ea       	ldi	r24, 0xAD	; 173
     958:	92 e0       	ldi	r25, 0x02	; 2
     95a:	60 e0       	ldi	r22, 0x00	; 0
     95c:	70 e0       	ldi	r23, 0x00	; 0
     95e:	4b e0       	ldi	r20, 0x0B	; 11
     960:	50 e0       	ldi	r21, 0x00	; 0
     962:	24 e0       	ldi	r18, 0x04	; 4
     964:	33 e0       	ldi	r19, 0x03	; 3
     966:	0e 94 2a 06 	call	0xc54	; 0xc54 <__eerd_block>
     96a:	c1 ec       	ldi	r28, 0xC1	; 193
     96c:	d2 e0       	ldi	r29, 0x02	; 2
     96e:	ce 01       	movw	r24, r28
     970:	66 e1       	ldi	r22, 0x16	; 22
     972:	70 e0       	ldi	r23, 0x00	; 0
     974:	4f ef       	ldi	r20, 0xFF	; 255
     976:	50 e0       	ldi	r21, 0x00	; 0
     978:	24 e0       	ldi	r18, 0x04	; 4
     97a:	33 e0       	ldi	r19, 0x03	; 3
     97c:	0e 94 2a 06 	call	0xc54	; 0xc54 <__eerd_block>
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	80 93 c4 03 	sts	0x03C4, r24

//	ledText_displayText="..."; //time; //text1; //exampleText;
//	ledText_newDisplayText=ledText_displayText;
//	ledText_displayText=text1; //exampleText;

	activeText=&ledText[ledText_newTextId];
     986:	80 91 c4 03 	lds	r24, 0x03C4
     98a:	2b e0       	ldi	r18, 0x0B	; 11
     98c:	82 9f       	mul	r24, r18
     98e:	c0 01       	movw	r24, r0
     990:	11 24       	eor	r1, r1
     992:	8e 55       	subi	r24, 0x5E	; 94
     994:	9d 4f       	sbci	r25, 0xFD	; 253
     996:	90 93 c1 03 	sts	0x03C1, r25
     99a:	80 93 c0 03 	sts	0x03C0, r24
	switch (ledText_newTextId)
     99e:	80 91 c4 03 	lds	r24, 0x03C4
     9a2:	88 23       	and	r24, r24
     9a4:	19 f0       	breq	.+6      	; 0x9ac <ledText_init+0x6e>
     9a6:	81 30       	cpi	r24, 0x01	; 1
     9a8:	61 f4       	brne	.+24     	; 0x9c2 <ledText_init+0x84>
     9aa:	07 c0       	rjmp	.+14     	; 0x9ba <ledText_init+0x7c>
	{
		case 0: activeString = ledText_time; break;
     9ac:	88 eb       	ldi	r24, 0xB8	; 184
     9ae:	92 e0       	ldi	r25, 0x02	; 2
     9b0:	90 93 c3 03 	sts	0x03C3, r25
     9b4:	80 93 c2 03 	sts	0x03C2, r24
     9b8:	04 c0       	rjmp	.+8      	; 0x9c2 <ledText_init+0x84>
		case 1: activeString = ledText_customString; break;
     9ba:	d0 93 c3 03 	sts	0x03C3, r29
     9be:	c0 93 c2 03 	sts	0x03C2, r28
	}

	ledText_firstCharIndex=0;
     9c2:	10 92 a0 02 	sts	0x02A0, r1
	ledText_firstCharSubIndex=0;
     9c6:	10 92 a1 02 	sts	0x02A1, r1
	ledText_seqCounter=0;
     9ca:	10 92 9b 02 	sts	0x029B, r1

	ledText_beginSequence();
     9ce:	0e 94 1c 03 	call	0x638	; 0x638 <ledText_beginSequence>
}
     9d2:	df 91       	pop	r29
     9d4:	cf 91       	pop	r28
     9d6:	08 95       	ret

000009d8 <writeTextToEEPROM>:
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
     9d8:	86 e1       	ldi	r24, 0x16	; 22
     9da:	90 e0       	ldi	r25, 0x00	; 0
     9dc:	61 ec       	ldi	r22, 0xC1	; 193
     9de:	72 e0       	ldi	r23, 0x02	; 2
     9e0:	4f ef       	ldi	r20, 0xFF	; 255
     9e2:	50 e0       	ldi	r21, 0x00	; 0
     9e4:	2c e0       	ldi	r18, 0x0C	; 12
     9e6:	33 e0       	ldi	r19, 0x03	; 3
     9e8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__eewr_block>
}

void writeTextToEEPROM()
{
	eeprom_write_block((const void*)&ledText_customString, (void*)&EE_ledText_CustomString, 255);
}
     9ec:	08 95       	ret

000009ee <writeSettingsToEEPROM>:
	ledText_seqCounter=0;
}

void writeSettingsToEEPROM(uint8_t id)
{
	switch (id)
     9ee:	88 23       	and	r24, r24
     9f0:	19 f0       	breq	.+6      	; 0x9f8 <writeSettingsToEEPROM+0xa>
     9f2:	81 30       	cpi	r24, 0x01	; 1
     9f4:	b1 f4       	brne	.+44     	; 0xa22 <writeSettingsToEEPROM+0x34>
     9f6:	0b c0       	rjmp	.+22     	; 0xa0e <writeSettingsToEEPROM+0x20>
     9f8:	8b e0       	ldi	r24, 0x0B	; 11
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	62 ea       	ldi	r22, 0xA2	; 162
     9fe:	72 e0       	ldi	r23, 0x02	; 2
     a00:	4b e0       	ldi	r20, 0x0B	; 11
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	2c e0       	ldi	r18, 0x0C	; 12
     a06:	33 e0       	ldi	r19, 0x03	; 3
     a08:	0e 94 46 06 	call	0xc8c	; 0xc8c <__eewr_block>
     a0c:	08 95       	ret
	{
		case 0:	//time
			eeprom_write_block((const void*)&ledText[0], (void*)&EE_ledText_TimeSettings, sizeof(ledText_Type));
			break;		
     a0e:	80 e0       	ldi	r24, 0x00	; 0
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	6d ea       	ldi	r22, 0xAD	; 173
     a14:	72 e0       	ldi	r23, 0x02	; 2
     a16:	4b e0       	ldi	r20, 0x0B	; 11
     a18:	50 e0       	ldi	r21, 0x00	; 0
     a1a:	2c e0       	ldi	r18, 0x0C	; 12
     a1c:	33 e0       	ldi	r19, 0x03	; 3
     a1e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__eewr_block>
     a22:	08 95       	ret

00000a24 <changeCustomText>:
	memcpy ((uint8_t*)&ledText[id], (uint8_t*)buf, sizeof(ledText_Type));
}

void changeCustomText(char *buf)
{
	memcpy ((char*)&ledText_customString, (char*)buf, 255);
     a24:	a1 ec       	ldi	r26, 0xC1	; 193
     a26:	b2 e0       	ldi	r27, 0x02	; 2
     a28:	fc 01       	movw	r30, r24
     a2a:	8f ef       	ldi	r24, 0xFF	; 255
     a2c:	01 90       	ld	r0, Z+
     a2e:	0d 92       	st	X+, r0
     a30:	81 50       	subi	r24, 0x01	; 1
     a32:	e1 f7       	brne	.-8      	; 0xa2c <changeCustomText+0x8>

	ledText_firstCharIndex=0;
     a34:	10 92 a0 02 	sts	0x02A0, r1
	ledText_firstCharSubIndex=0;
     a38:	10 92 a1 02 	sts	0x02A1, r1
	ledText_seqCounter=0;
     a3c:	10 92 9b 02 	sts	0x029B, r1
}
     a40:	08 95       	ret

00000a42 <changeSettings>:
	sprintf((char*)ledText_time, "%02d:%02d:%02d", h, m, s);
}

void changeSettings(uint8_t id, uint8_t *buf)
{
	memcpy ((uint8_t*)&ledText[id], (uint8_t*)buf, sizeof(ledText_Type));
     a42:	9b e0       	ldi	r25, 0x0B	; 11
     a44:	89 9f       	mul	r24, r25
     a46:	f0 01       	movw	r30, r0
     a48:	11 24       	eor	r1, r1
     a4a:	ee 55       	subi	r30, 0x5E	; 94
     a4c:	fd 4f       	sbci	r31, 0xFD	; 253
     a4e:	db 01       	movw	r26, r22
     a50:	8b e0       	ldi	r24, 0x0B	; 11
     a52:	0d 90       	ld	r0, X+
     a54:	01 92       	st	Z+, r0
     a56:	81 50       	subi	r24, 0x01	; 1
     a58:	e1 f7       	brne	.-8      	; 0xa52 <changeSettings+0x10>
}
     a5a:	08 95       	ret

00000a5c <changeTime>:
	ledText_newTextId=id;
}

void changeTime(uint8_t h, uint8_t m, uint8_t s)
{
	sprintf((char*)ledText_time, "%02d:%02d:%02d", h, m, s);
     a5c:	2d b7       	in	r18, 0x3d	; 61
     a5e:	3e b7       	in	r19, 0x3e	; 62
     a60:	2a 50       	subi	r18, 0x0A	; 10
     a62:	30 40       	sbci	r19, 0x00	; 0
     a64:	0f b6       	in	r0, 0x3f	; 63
     a66:	f8 94       	cli
     a68:	3e bf       	out	0x3e, r19	; 62
     a6a:	0f be       	out	0x3f, r0	; 63
     a6c:	2d bf       	out	0x3d, r18	; 61
     a6e:	ed b7       	in	r30, 0x3d	; 61
     a70:	fe b7       	in	r31, 0x3e	; 62
     a72:	31 96       	adiw	r30, 0x01	; 1
     a74:	28 eb       	ldi	r18, 0xB8	; 184
     a76:	32 e0       	ldi	r19, 0x02	; 2
     a78:	ad b7       	in	r26, 0x3d	; 61
     a7a:	be b7       	in	r27, 0x3e	; 62
     a7c:	12 96       	adiw	r26, 0x02	; 2
     a7e:	3c 93       	st	X, r19
     a80:	2e 93       	st	-X, r18
     a82:	11 97       	sbiw	r26, 0x01	; 1
     a84:	20 e0       	ldi	r18, 0x00	; 0
     a86:	31 e0       	ldi	r19, 0x01	; 1
     a88:	33 83       	std	Z+3, r19	; 0x03
     a8a:	22 83       	std	Z+2, r18	; 0x02
     a8c:	84 83       	std	Z+4, r24	; 0x04
     a8e:	15 82       	std	Z+5, r1	; 0x05
     a90:	66 83       	std	Z+6, r22	; 0x06
     a92:	17 82       	std	Z+7, r1	; 0x07
     a94:	40 87       	std	Z+8, r20	; 0x08
     a96:	11 86       	std	Z+9, r1	; 0x09
     a98:	0e 94 62 06 	call	0xcc4	; 0xcc4 <sprintf>
     a9c:	2d b7       	in	r18, 0x3d	; 61
     a9e:	3e b7       	in	r19, 0x3e	; 62
     aa0:	26 5f       	subi	r18, 0xF6	; 246
     aa2:	3f 4f       	sbci	r19, 0xFF	; 255
     aa4:	0f b6       	in	r0, 0x3f	; 63
     aa6:	f8 94       	cli
     aa8:	3e bf       	out	0x3e, r19	; 62
     aaa:	0f be       	out	0x3f, r0	; 63
     aac:	2d bf       	out	0x3d, r18	; 61
}
     aae:	08 95       	ret

00000ab0 <USART_Init>:

void USART_Init()
{
	unsigned int ubrr = UBRR_VAL;
	/*Set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
     ab0:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (unsigned char)ubrr;
     ab4:	8c e0       	ldi	r24, 0x0C	; 12
     ab6:	80 93 c4 00 	sts	0x00C4, r24
	/*Enable receiver and transmitter  and interrrupts*/
	UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1<<RXCIE0);
     aba:	88 e9       	ldi	r24, 0x98	; 152
     abc:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 2stop bit */
	UCSR0C = (1<<USBS0)|(3<<UCSZ00);
     ac0:	8e e0       	ldi	r24, 0x0E	; 14
     ac2:	80 93 c2 00 	sts	0x00C2, r24
}
     ac6:	08 95       	ret

00000ac8 <USART_Receive>:


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     ac8:	80 91 c0 00 	lds	r24, 0x00C0
     acc:	87 ff       	sbrs	r24, 7
     ace:	fc cf       	rjmp	.-8      	; 0xac8 <USART_Receive>
		;
	/* Get and return received data from buffer */
	return UDR0;
     ad0:	80 91 c6 00 	lds	r24, 0x00C6
}
     ad4:	08 95       	ret

00000ad6 <USART_Transmit>:

void USART_Transmit( unsigned char data )
{
     ad6:	98 2f       	mov	r25, r24
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
     ad8:	80 91 c0 00 	lds	r24, 0x00C0
     adc:	85 ff       	sbrs	r24, 5
     ade:	fc cf       	rjmp	.-8      	; 0xad8 <USART_Transmit+0x2>
		;
	/* Put data into buffer, sends the data */
	UDR0 = data;
     ae0:	90 93 c6 00 	sts	0x00C6, r25
}
     ae4:	08 95       	ret

00000ae6 <USART_receiveBlock>:

void USART_receiveBlock(uint8_t *buf, int size)
{
     ae6:	ac 01       	movw	r20, r24
     ae8:	20 e0       	ldi	r18, 0x00	; 0
     aea:	30 e0       	ldi	r19, 0x00	; 0
     aec:	0c c0       	rjmp	.+24     	; 0xb06 <USART_receiveBlock+0x20>


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     aee:	80 91 c0 00 	lds	r24, 0x00C0
     af2:	87 ff       	sbrs	r24, 7
     af4:	fc cf       	rjmp	.-8      	; 0xaee <USART_receiveBlock+0x8>
		;
	/* Get and return received data from buffer */
	return UDR0;
     af6:	80 91 c6 00 	lds	r24, 0x00C6

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
	{
		*(buf+i)=(uint8_t)USART_Receive();
     afa:	fa 01       	movw	r30, r20
     afc:	e2 0f       	add	r30, r18
     afe:	f3 1f       	adc	r31, r19
     b00:	80 83       	st	Z, r24
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     b02:	2f 5f       	subi	r18, 0xFF	; 255
     b04:	3f 4f       	sbci	r19, 0xFF	; 255
     b06:	26 17       	cp	r18, r22
     b08:	37 07       	cpc	r19, r23
     b0a:	8c f3       	brlt	.-30     	; 0xaee <USART_receiveBlock+0x8>
	{
		*(buf+i)=(uint8_t)USART_Receive();
	}
}
     b0c:	08 95       	ret

00000b0e <USART_receiveString>:

void USART_receiveString(char *buf)
{
     b0e:	9c 01       	movw	r18, r24


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     b10:	80 91 c0 00 	lds	r24, 0x00C0
     b14:	87 ff       	sbrs	r24, 7
     b16:	fc cf       	rjmp	.-8      	; 0xb10 <USART_receiveString+0x2>
		;
	/* Get and return received data from buffer */
	return UDR0;
     b18:	80 91 c6 00 	lds	r24, 0x00C6
     b1c:	a0 e0       	ldi	r26, 0x00	; 0
     b1e:	b0 e0       	ldi	r27, 0x00	; 0
     b20:	0e c0       	rjmp	.+28     	; 0xb3e <USART_receiveString+0x30>
{
	unsigned char c=USART_Receive();
	int i;
	for (i=0;i<255 && c>0;i++)
	{
		*(buf+i)=c;
     b22:	f9 01       	movw	r30, r18
     b24:	ea 0f       	add	r30, r26
     b26:	fb 1f       	adc	r31, r27
     b28:	80 83       	st	Z, r24


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     b2a:	80 91 c0 00 	lds	r24, 0x00C0
     b2e:	87 ff       	sbrs	r24, 7
     b30:	fc cf       	rjmp	.-8      	; 0xb2a <USART_receiveString+0x1c>
		;
	/* Get and return received data from buffer */
	return UDR0;
     b32:	80 91 c6 00 	lds	r24, 0x00C6

void USART_receiveString(char *buf)
{
	unsigned char c=USART_Receive();
	int i;
	for (i=0;i<255 && c>0;i++)
     b36:	11 96       	adiw	r26, 0x01	; 1
     b38:	af 3f       	cpi	r26, 0xFF	; 255
     b3a:	b1 05       	cpc	r27, r1
     b3c:	11 f0       	breq	.+4      	; 0xb42 <USART_receiveString+0x34>
     b3e:	88 23       	and	r24, r24
     b40:	81 f7       	brne	.-32     	; 0xb22 <USART_receiveString+0x14>
	{
		*(buf+i)=c;
		c=USART_Receive();
	}
	*(buf+i)=0;
     b42:	a2 0f       	add	r26, r18
     b44:	b3 1f       	adc	r27, r19
     b46:	1c 92       	st	X, r1
}
     b48:	08 95       	ret

00000b4a <USART_sendString>:

void USART_sendString(char *buf)
{
     b4a:	fc 01       	movw	r30, r24
     b4c:	07 c0       	rjmp	.+14     	; 0xb5c <USART_sendString+0x12>
}

void USART_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
     b4e:	80 91 c0 00 	lds	r24, 0x00C0
     b52:	85 ff       	sbrs	r24, 5
     b54:	fc cf       	rjmp	.-8      	; 0xb4e <USART_sendString+0x4>
		;
	/* Put data into buffer, sends the data */
	UDR0 = data;
     b56:	90 93 c6 00 	sts	0x00C6, r25
void USART_sendString(char *buf)
{
	while (*(buf)!=0)
	{
		USART_Transmit(*(buf));
		buf++;
     b5a:	31 96       	adiw	r30, 0x01	; 1
	*(buf+i)=0;
}

void USART_sendString(char *buf)
{
	while (*(buf)!=0)
     b5c:	90 81       	ld	r25, Z
     b5e:	99 23       	and	r25, r25
     b60:	b1 f7       	brne	.-20     	; 0xb4e <USART_sendString+0x4>
	{
		USART_Transmit(*(buf));
		buf++;
	}
}
     b62:	08 95       	ret

00000b64 <USART_RX_INT>:
			5 Bytes (Stunde, Minute, Sekunde, Milisekunden (2 Bytes))
		Aktion=3:
			255 Bytes (Text, Ende mit 0 gekennzeichnet)
*/
void USART_RX_INT()
{
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	df 93       	push	r29
     b6a:	cf 93       	push	r28
     b6c:	cd b7       	in	r28, 0x3d	; 61
     b6e:	de b7       	in	r29, 0x3e	; 62
     b70:	cf 50       	subi	r28, 0x0F	; 15
     b72:	d1 40       	sbci	r29, 0x01	; 1
     b74:	0f b6       	in	r0, 0x3f	; 63
     b76:	f8 94       	cli
     b78:	de bf       	out	0x3e, r29	; 62
     b7a:	0f be       	out	0x3f, r0	; 63
     b7c:	cd bf       	out	0x3d, r28	; 61


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     b7e:	80 91 c0 00 	lds	r24, 0x00C0
     b82:	87 ff       	sbrs	r24, 7
     b84:	fc cf       	rjmp	.-8      	; 0xb7e <USART_RX_INT+0x1a>
		;
	/* Get and return received data from buffer */
	return UDR0;
     b86:	10 91 c6 00 	lds	r17, 0x00C6


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     b8a:	80 91 c0 00 	lds	r24, 0x00C0
     b8e:	87 ff       	sbrs	r24, 7
     b90:	fc cf       	rjmp	.-8      	; 0xb8a <USART_RX_INT+0x26>
		;
	/* Get and return received data from buffer */
	return UDR0;
     b92:	00 91 c6 00 	lds	r16, 0x00C6
	uint8_t bufTime[5]; 		//HMSms

	uint8_t action = USART_Receive();
	uint8_t writeToEEPROM = USART_Receive();

	switch (action)
     b96:	12 30       	cpi	r17, 0x02	; 2
     b98:	f9 f0       	breq	.+62     	; 0xbd8 <USART_RX_INT+0x74>
     b9a:	12 30       	cpi	r17, 0x02	; 2
     b9c:	20 f0       	brcs	.+8      	; 0xba6 <USART_RX_INT+0x42>
     b9e:	13 30       	cpi	r17, 0x03	; 3
     ba0:	09 f0       	breq	.+2      	; 0xba4 <USART_RX_INT+0x40>
     ba2:	4c c0       	rjmp	.+152    	; 0xc3c <USART_RX_INT+0xd8>
     ba4:	33 c0       	rjmp	.+102    	; 0xc0c <USART_RX_INT+0xa8>
     ba6:	fe 01       	movw	r30, r28
     ba8:	36 96       	adiw	r30, 0x06	; 6
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     baa:	bf 01       	movw	r22, r30
     bac:	9e 01       	movw	r18, r28
     bae:	2f 5e       	subi	r18, 0xEF	; 239
     bb0:	3f 4f       	sbci	r19, 0xFF	; 255


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     bb2:	80 91 c0 00 	lds	r24, 0x00C0
     bb6:	87 ff       	sbrs	r24, 7
     bb8:	fc cf       	rjmp	.-8      	; 0xbb2 <USART_RX_INT+0x4e>
		;
	/* Get and return received data from buffer */
	return UDR0;
     bba:	80 91 c6 00 	lds	r24, 0x00C6

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
	{
		*(buf+i)=(uint8_t)USART_Receive();
     bbe:	81 93       	st	Z+, r24
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     bc0:	e2 17       	cp	r30, r18
     bc2:	f3 07       	cpc	r31, r19
     bc4:	b1 f7       	brne	.-20     	; 0xbb2 <USART_RX_INT+0x4e>
	switch (action)
	{
		case UART_changeTimeSettings:
		case UART_changeTextSettings:
			USART_receiveBlock((uint8_t*)&bufSettings,sizeof(ledText_Type));
			changeSettings(action, bufSettings);
     bc6:	81 2f       	mov	r24, r17
     bc8:	0e 94 21 05 	call	0xa42	; 0xa42 <changeSettings>
			if (writeToEEPROM!=0)
     bcc:	00 23       	and	r16, r16
     bce:	b1 f1       	breq	.+108    	; 0xc3c <USART_RX_INT+0xd8>
				writeSettingsToEEPROM(action);
     bd0:	81 2f       	mov	r24, r17
     bd2:	0e 94 f7 04 	call	0x9ee	; 0x9ee <writeSettingsToEEPROM>
     bd6:	32 c0       	rjmp	.+100    	; 0xc3c <USART_RX_INT+0xd8>
     bd8:	fe 01       	movw	r30, r28
     bda:	31 96       	adiw	r30, 0x01	; 1
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     bdc:	9e 01       	movw	r18, r28
     bde:	2a 5f       	subi	r18, 0xFA	; 250
     be0:	3f 4f       	sbci	r19, 0xFF	; 255


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     be2:	80 91 c0 00 	lds	r24, 0x00C0
     be6:	87 ff       	sbrs	r24, 7
     be8:	fc cf       	rjmp	.-8      	; 0xbe2 <USART_RX_INT+0x7e>
		;
	/* Get and return received data from buffer */
	return UDR0;
     bea:	80 91 c6 00 	lds	r24, 0x00C6

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
	{
		*(buf+i)=(uint8_t)USART_Receive();
     bee:	81 93       	st	Z+, r24
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     bf0:	e2 17       	cp	r30, r18
     bf2:	f3 07       	cpc	r31, r19
     bf4:	b1 f7       	brne	.-20     	; 0xbe2 <USART_RX_INT+0x7e>
			if (writeToEEPROM!=0)
				writeSettingsToEEPROM(action);
			break;
		case UART_changeTime:
			USART_receiveBlock((uint8_t*)&bufTime,5);
			setTime(bufTime[0], bufTime[1], bufTime[2], (uint16_t) (bufTime[3] + (bufTime[4]<<8)));
     bf6:	3d 81       	ldd	r19, Y+5	; 0x05
     bf8:	20 e0       	ldi	r18, 0x00	; 0
     bfa:	8c 81       	ldd	r24, Y+4	; 0x04
     bfc:	28 0f       	add	r18, r24
     bfe:	31 1d       	adc	r19, r1
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	6a 81       	ldd	r22, Y+2	; 0x02
     c04:	4b 81       	ldd	r20, Y+3	; 0x03
     c06:	0e 94 53 00 	call	0xa6	; 0xa6 <setTime>
     c0a:	18 c0       	rjmp	.+48     	; 0xc3c <USART_RX_INT+0xd8>
			break;
     c0c:	fe 01       	movw	r30, r28
     c0e:	71 96       	adiw	r30, 0x11	; 17
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     c10:	cf 01       	movw	r24, r30
     c12:	4e 2f       	mov	r20, r30
     c14:	9e 01       	movw	r18, r28
     c16:	20 5f       	subi	r18, 0xF0	; 240
     c18:	3e 4f       	sbci	r19, 0xFE	; 254


unsigned char USART_Receive( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     c1a:	80 91 c0 00 	lds	r24, 0x00C0
     c1e:	87 ff       	sbrs	r24, 7
     c20:	fc cf       	rjmp	.-8      	; 0xc1a <USART_RX_INT+0xb6>
		;
	/* Get and return received data from buffer */
	return UDR0;
     c22:	80 91 c6 00 	lds	r24, 0x00C6

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
	{
		*(buf+i)=(uint8_t)USART_Receive();
     c26:	81 93       	st	Z+, r24
	UDR0 = data;
}

void USART_receiveBlock(uint8_t *buf, int size)
{
	for (int i=0;i<size;i++)
     c28:	e2 17       	cp	r30, r18
     c2a:	f3 07       	cpc	r31, r19
     c2c:	b1 f7       	brne	.-20     	; 0xc1a <USART_RX_INT+0xb6>
			USART_receiveBlock((uint8_t*)&bufTime,5);
			setTime(bufTime[0], bufTime[1], bufTime[2], (uint16_t) (bufTime[3] + (bufTime[4]<<8)));
			break;
		case UART_changeText:
			USART_receiveBlock((uint8_t*)&bufText, 255);
			changeCustomText((char*)bufText);	
     c2e:	84 2f       	mov	r24, r20
     c30:	0e 94 12 05 	call	0xa24	; 0xa24 <changeCustomText>
			if (writeToEEPROM!=0)
     c34:	00 23       	and	r16, r16
     c36:	11 f0       	breq	.+4      	; 0xc3c <USART_RX_INT+0xd8>
				writeTextToEEPROM();
     c38:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <writeTextToEEPROM>
	char ret[50];
	sprintf((char*)ret, "%d Zeichen empfangen.", strlen((char*)USART_buffer));
	USART_sendString(ret);
	changeText((char*)USART_buffer);
*/
}
     c3c:	c1 5f       	subi	r28, 0xF1	; 241
     c3e:	de 4f       	sbci	r29, 0xFE	; 254
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	cf 91       	pop	r28
     c4c:	df 91       	pop	r29
     c4e:	1f 91       	pop	r17
     c50:	0f 91       	pop	r16
     c52:	08 95       	ret

00000c54 <__eerd_block>:
     c54:	a0 e0       	ldi	r26, 0x00	; 0
     c56:	b0 e0       	ldi	r27, 0x00	; 0
     c58:	e0 e3       	ldi	r30, 0x30	; 48
     c5a:	f6 e0       	ldi	r31, 0x06	; 6
     c5c:	0c 94 0d 09 	jmp	0x121a	; 0x121a <__prologue_saves__+0x14>
     c60:	7c 01       	movw	r14, r24
     c62:	eb 01       	movw	r28, r22
     c64:	8a 01       	movw	r16, r20
     c66:	69 01       	movw	r12, r18
     c68:	09 c0       	rjmp	.+18     	; 0xc7c <__eerd_block+0x28>
     c6a:	ce 01       	movw	r24, r28
     c6c:	21 96       	adiw	r28, 0x01	; 1
     c6e:	f6 01       	movw	r30, r12
     c70:	09 95       	icall
     c72:	f7 01       	movw	r30, r14
     c74:	81 93       	st	Z+, r24
     c76:	7f 01       	movw	r14, r30
     c78:	01 50       	subi	r16, 0x01	; 1
     c7a:	10 40       	sbci	r17, 0x00	; 0
     c7c:	01 15       	cp	r16, r1
     c7e:	11 05       	cpc	r17, r1
     c80:	a1 f7       	brne	.-24     	; 0xc6a <__eerd_block+0x16>
     c82:	cd b7       	in	r28, 0x3d	; 61
     c84:	de b7       	in	r29, 0x3e	; 62
     c86:	e8 e0       	ldi	r30, 0x08	; 8
     c88:	0c 94 29 09 	jmp	0x1252	; 0x1252 <__epilogue_restores__+0x14>

00000c8c <__eewr_block>:
     c8c:	a0 e0       	ldi	r26, 0x00	; 0
     c8e:	b0 e0       	ldi	r27, 0x00	; 0
     c90:	ec e4       	ldi	r30, 0x4C	; 76
     c92:	f6 e0       	ldi	r31, 0x06	; 6
     c94:	0c 94 0d 09 	jmp	0x121a	; 0x121a <__prologue_saves__+0x14>
     c98:	ec 01       	movw	r28, r24
     c9a:	7b 01       	movw	r14, r22
     c9c:	8a 01       	movw	r16, r20
     c9e:	69 01       	movw	r12, r18
     ca0:	09 c0       	rjmp	.+18     	; 0xcb4 <__eewr_block+0x28>
     ca2:	ce 01       	movw	r24, r28
     ca4:	21 96       	adiw	r28, 0x01	; 1
     ca6:	f7 01       	movw	r30, r14
     ca8:	61 91       	ld	r22, Z+
     caa:	7f 01       	movw	r14, r30
     cac:	f6 01       	movw	r30, r12
     cae:	09 95       	icall
     cb0:	01 50       	subi	r16, 0x01	; 1
     cb2:	10 40       	sbci	r17, 0x00	; 0
     cb4:	01 15       	cp	r16, r1
     cb6:	11 05       	cpc	r17, r1
     cb8:	a1 f7       	brne	.-24     	; 0xca2 <__eewr_block+0x16>
     cba:	cd b7       	in	r28, 0x3d	; 61
     cbc:	de b7       	in	r29, 0x3e	; 62
     cbe:	e8 e0       	ldi	r30, 0x08	; 8
     cc0:	0c 94 29 09 	jmp	0x1252	; 0x1252 <__epilogue_restores__+0x14>

00000cc4 <sprintf>:
     cc4:	ae e0       	ldi	r26, 0x0E	; 14
     cc6:	b0 e0       	ldi	r27, 0x00	; 0
     cc8:	e8 e6       	ldi	r30, 0x68	; 104
     cca:	f6 e0       	ldi	r31, 0x06	; 6
     ccc:	0c 94 11 09 	jmp	0x1222	; 0x1222 <__prologue_saves__+0x1c>
     cd0:	0d 89       	ldd	r16, Y+21	; 0x15
     cd2:	1e 89       	ldd	r17, Y+22	; 0x16
     cd4:	86 e0       	ldi	r24, 0x06	; 6
     cd6:	8c 83       	std	Y+4, r24	; 0x04
     cd8:	1a 83       	std	Y+2, r17	; 0x02
     cda:	09 83       	std	Y+1, r16	; 0x01
     cdc:	8f ef       	ldi	r24, 0xFF	; 255
     cde:	9f e7       	ldi	r25, 0x7F	; 127
     ce0:	9e 83       	std	Y+6, r25	; 0x06
     ce2:	8d 83       	std	Y+5, r24	; 0x05
     ce4:	9e 01       	movw	r18, r28
     ce6:	27 5e       	subi	r18, 0xE7	; 231
     ce8:	3f 4f       	sbci	r19, 0xFF	; 255
     cea:	ce 01       	movw	r24, r28
     cec:	01 96       	adiw	r24, 0x01	; 1
     cee:	6f 89       	ldd	r22, Y+23	; 0x17
     cf0:	78 8d       	ldd	r23, Y+24	; 0x18
     cf2:	a9 01       	movw	r20, r18
     cf4:	0e 94 86 06 	call	0xd0c	; 0xd0c <vfprintf>
     cf8:	2f 81       	ldd	r18, Y+7	; 0x07
     cfa:	38 85       	ldd	r19, Y+8	; 0x08
     cfc:	02 0f       	add	r16, r18
     cfe:	13 1f       	adc	r17, r19
     d00:	f8 01       	movw	r30, r16
     d02:	10 82       	st	Z, r1
     d04:	2e 96       	adiw	r28, 0x0e	; 14
     d06:	e4 e0       	ldi	r30, 0x04	; 4
     d08:	0c 94 2d 09 	jmp	0x125a	; 0x125a <__epilogue_restores__+0x1c>

00000d0c <vfprintf>:
     d0c:	ab e0       	ldi	r26, 0x0B	; 11
     d0e:	b0 e0       	ldi	r27, 0x00	; 0
     d10:	ec e8       	ldi	r30, 0x8C	; 140
     d12:	f6 e0       	ldi	r31, 0x06	; 6
     d14:	0c 94 03 09 	jmp	0x1206	; 0x1206 <__prologue_saves__>
     d18:	3c 01       	movw	r6, r24
     d1a:	2b 01       	movw	r4, r22
     d1c:	5a 01       	movw	r10, r20
     d1e:	fc 01       	movw	r30, r24
     d20:	17 82       	std	Z+7, r1	; 0x07
     d22:	16 82       	std	Z+6, r1	; 0x06
     d24:	83 81       	ldd	r24, Z+3	; 0x03
     d26:	81 fd       	sbrc	r24, 1
     d28:	03 c0       	rjmp	.+6      	; 0xd30 <vfprintf+0x24>
     d2a:	6f ef       	ldi	r22, 0xFF	; 255
     d2c:	7f ef       	ldi	r23, 0xFF	; 255
     d2e:	c6 c1       	rjmp	.+908    	; 0x10bc <vfprintf+0x3b0>
     d30:	9a e0       	ldi	r25, 0x0A	; 10
     d32:	89 2e       	mov	r8, r25
     d34:	1e 01       	movw	r2, r28
     d36:	08 94       	sec
     d38:	21 1c       	adc	r2, r1
     d3a:	31 1c       	adc	r3, r1
     d3c:	f3 01       	movw	r30, r6
     d3e:	23 81       	ldd	r18, Z+3	; 0x03
     d40:	f2 01       	movw	r30, r4
     d42:	23 fd       	sbrc	r18, 3
     d44:	85 91       	lpm	r24, Z+
     d46:	23 ff       	sbrs	r18, 3
     d48:	81 91       	ld	r24, Z+
     d4a:	2f 01       	movw	r4, r30
     d4c:	88 23       	and	r24, r24
     d4e:	09 f4       	brne	.+2      	; 0xd52 <vfprintf+0x46>
     d50:	b2 c1       	rjmp	.+868    	; 0x10b6 <vfprintf+0x3aa>
     d52:	85 32       	cpi	r24, 0x25	; 37
     d54:	39 f4       	brne	.+14     	; 0xd64 <vfprintf+0x58>
     d56:	23 fd       	sbrc	r18, 3
     d58:	85 91       	lpm	r24, Z+
     d5a:	23 ff       	sbrs	r18, 3
     d5c:	81 91       	ld	r24, Z+
     d5e:	2f 01       	movw	r4, r30
     d60:	85 32       	cpi	r24, 0x25	; 37
     d62:	29 f4       	brne	.+10     	; 0xd6e <vfprintf+0x62>
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	b3 01       	movw	r22, r6
     d68:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
     d6c:	e7 cf       	rjmp	.-50     	; 0xd3c <vfprintf+0x30>
     d6e:	98 2f       	mov	r25, r24
     d70:	ff 24       	eor	r15, r15
     d72:	ee 24       	eor	r14, r14
     d74:	99 24       	eor	r9, r9
     d76:	ff e1       	ldi	r31, 0x1F	; 31
     d78:	ff 15       	cp	r31, r15
     d7a:	d0 f0       	brcs	.+52     	; 0xdb0 <vfprintf+0xa4>
     d7c:	9b 32       	cpi	r25, 0x2B	; 43
     d7e:	69 f0       	breq	.+26     	; 0xd9a <vfprintf+0x8e>
     d80:	9c 32       	cpi	r25, 0x2C	; 44
     d82:	28 f4       	brcc	.+10     	; 0xd8e <vfprintf+0x82>
     d84:	90 32       	cpi	r25, 0x20	; 32
     d86:	59 f0       	breq	.+22     	; 0xd9e <vfprintf+0x92>
     d88:	93 32       	cpi	r25, 0x23	; 35
     d8a:	91 f4       	brne	.+36     	; 0xdb0 <vfprintf+0xa4>
     d8c:	0e c0       	rjmp	.+28     	; 0xdaa <vfprintf+0x9e>
     d8e:	9d 32       	cpi	r25, 0x2D	; 45
     d90:	49 f0       	breq	.+18     	; 0xda4 <vfprintf+0x98>
     d92:	90 33       	cpi	r25, 0x30	; 48
     d94:	69 f4       	brne	.+26     	; 0xdb0 <vfprintf+0xa4>
     d96:	41 e0       	ldi	r20, 0x01	; 1
     d98:	24 c0       	rjmp	.+72     	; 0xde2 <vfprintf+0xd6>
     d9a:	52 e0       	ldi	r21, 0x02	; 2
     d9c:	f5 2a       	or	r15, r21
     d9e:	84 e0       	ldi	r24, 0x04	; 4
     da0:	f8 2a       	or	r15, r24
     da2:	28 c0       	rjmp	.+80     	; 0xdf4 <vfprintf+0xe8>
     da4:	98 e0       	ldi	r25, 0x08	; 8
     da6:	f9 2a       	or	r15, r25
     da8:	25 c0       	rjmp	.+74     	; 0xdf4 <vfprintf+0xe8>
     daa:	e0 e1       	ldi	r30, 0x10	; 16
     dac:	fe 2a       	or	r15, r30
     dae:	22 c0       	rjmp	.+68     	; 0xdf4 <vfprintf+0xe8>
     db0:	f7 fc       	sbrc	r15, 7
     db2:	29 c0       	rjmp	.+82     	; 0xe06 <vfprintf+0xfa>
     db4:	89 2f       	mov	r24, r25
     db6:	80 53       	subi	r24, 0x30	; 48
     db8:	8a 30       	cpi	r24, 0x0A	; 10
     dba:	70 f4       	brcc	.+28     	; 0xdd8 <vfprintf+0xcc>
     dbc:	f6 fe       	sbrs	r15, 6
     dbe:	05 c0       	rjmp	.+10     	; 0xdca <vfprintf+0xbe>
     dc0:	98 9c       	mul	r9, r8
     dc2:	90 2c       	mov	r9, r0
     dc4:	11 24       	eor	r1, r1
     dc6:	98 0e       	add	r9, r24
     dc8:	15 c0       	rjmp	.+42     	; 0xdf4 <vfprintf+0xe8>
     dca:	e8 9c       	mul	r14, r8
     dcc:	e0 2c       	mov	r14, r0
     dce:	11 24       	eor	r1, r1
     dd0:	e8 0e       	add	r14, r24
     dd2:	f0 e2       	ldi	r31, 0x20	; 32
     dd4:	ff 2a       	or	r15, r31
     dd6:	0e c0       	rjmp	.+28     	; 0xdf4 <vfprintf+0xe8>
     dd8:	9e 32       	cpi	r25, 0x2E	; 46
     dda:	29 f4       	brne	.+10     	; 0xde6 <vfprintf+0xda>
     ddc:	f6 fc       	sbrc	r15, 6
     dde:	6b c1       	rjmp	.+726    	; 0x10b6 <vfprintf+0x3aa>
     de0:	40 e4       	ldi	r20, 0x40	; 64
     de2:	f4 2a       	or	r15, r20
     de4:	07 c0       	rjmp	.+14     	; 0xdf4 <vfprintf+0xe8>
     de6:	9c 36       	cpi	r25, 0x6C	; 108
     de8:	19 f4       	brne	.+6      	; 0xdf0 <vfprintf+0xe4>
     dea:	50 e8       	ldi	r21, 0x80	; 128
     dec:	f5 2a       	or	r15, r21
     dee:	02 c0       	rjmp	.+4      	; 0xdf4 <vfprintf+0xe8>
     df0:	98 36       	cpi	r25, 0x68	; 104
     df2:	49 f4       	brne	.+18     	; 0xe06 <vfprintf+0xfa>
     df4:	f2 01       	movw	r30, r4
     df6:	23 fd       	sbrc	r18, 3
     df8:	95 91       	lpm	r25, Z+
     dfa:	23 ff       	sbrs	r18, 3
     dfc:	91 91       	ld	r25, Z+
     dfe:	2f 01       	movw	r4, r30
     e00:	99 23       	and	r25, r25
     e02:	09 f0       	breq	.+2      	; 0xe06 <vfprintf+0xfa>
     e04:	b8 cf       	rjmp	.-144    	; 0xd76 <vfprintf+0x6a>
     e06:	89 2f       	mov	r24, r25
     e08:	85 54       	subi	r24, 0x45	; 69
     e0a:	83 30       	cpi	r24, 0x03	; 3
     e0c:	18 f0       	brcs	.+6      	; 0xe14 <vfprintf+0x108>
     e0e:	80 52       	subi	r24, 0x20	; 32
     e10:	83 30       	cpi	r24, 0x03	; 3
     e12:	38 f4       	brcc	.+14     	; 0xe22 <vfprintf+0x116>
     e14:	44 e0       	ldi	r20, 0x04	; 4
     e16:	50 e0       	ldi	r21, 0x00	; 0
     e18:	a4 0e       	add	r10, r20
     e1a:	b5 1e       	adc	r11, r21
     e1c:	5f e3       	ldi	r21, 0x3F	; 63
     e1e:	59 83       	std	Y+1, r21	; 0x01
     e20:	0f c0       	rjmp	.+30     	; 0xe40 <vfprintf+0x134>
     e22:	93 36       	cpi	r25, 0x63	; 99
     e24:	31 f0       	breq	.+12     	; 0xe32 <vfprintf+0x126>
     e26:	93 37       	cpi	r25, 0x73	; 115
     e28:	79 f0       	breq	.+30     	; 0xe48 <vfprintf+0x13c>
     e2a:	93 35       	cpi	r25, 0x53	; 83
     e2c:	09 f0       	breq	.+2      	; 0xe30 <vfprintf+0x124>
     e2e:	56 c0       	rjmp	.+172    	; 0xedc <vfprintf+0x1d0>
     e30:	20 c0       	rjmp	.+64     	; 0xe72 <vfprintf+0x166>
     e32:	f5 01       	movw	r30, r10
     e34:	80 81       	ld	r24, Z
     e36:	89 83       	std	Y+1, r24	; 0x01
     e38:	42 e0       	ldi	r20, 0x02	; 2
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	a4 0e       	add	r10, r20
     e3e:	b5 1e       	adc	r11, r21
     e40:	61 01       	movw	r12, r2
     e42:	01 e0       	ldi	r16, 0x01	; 1
     e44:	10 e0       	ldi	r17, 0x00	; 0
     e46:	12 c0       	rjmp	.+36     	; 0xe6c <vfprintf+0x160>
     e48:	f5 01       	movw	r30, r10
     e4a:	c0 80       	ld	r12, Z
     e4c:	d1 80       	ldd	r13, Z+1	; 0x01
     e4e:	f6 fc       	sbrc	r15, 6
     e50:	03 c0       	rjmp	.+6      	; 0xe58 <vfprintf+0x14c>
     e52:	6f ef       	ldi	r22, 0xFF	; 255
     e54:	7f ef       	ldi	r23, 0xFF	; 255
     e56:	02 c0       	rjmp	.+4      	; 0xe5c <vfprintf+0x150>
     e58:	69 2d       	mov	r22, r9
     e5a:	70 e0       	ldi	r23, 0x00	; 0
     e5c:	42 e0       	ldi	r20, 0x02	; 2
     e5e:	50 e0       	ldi	r21, 0x00	; 0
     e60:	a4 0e       	add	r10, r20
     e62:	b5 1e       	adc	r11, r21
     e64:	c6 01       	movw	r24, r12
     e66:	0e 94 6e 08 	call	0x10dc	; 0x10dc <strnlen>
     e6a:	8c 01       	movw	r16, r24
     e6c:	5f e7       	ldi	r21, 0x7F	; 127
     e6e:	f5 22       	and	r15, r21
     e70:	14 c0       	rjmp	.+40     	; 0xe9a <vfprintf+0x18e>
     e72:	f5 01       	movw	r30, r10
     e74:	c0 80       	ld	r12, Z
     e76:	d1 80       	ldd	r13, Z+1	; 0x01
     e78:	f6 fc       	sbrc	r15, 6
     e7a:	03 c0       	rjmp	.+6      	; 0xe82 <vfprintf+0x176>
     e7c:	6f ef       	ldi	r22, 0xFF	; 255
     e7e:	7f ef       	ldi	r23, 0xFF	; 255
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <vfprintf+0x17a>
     e82:	69 2d       	mov	r22, r9
     e84:	70 e0       	ldi	r23, 0x00	; 0
     e86:	42 e0       	ldi	r20, 0x02	; 2
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	a4 0e       	add	r10, r20
     e8c:	b5 1e       	adc	r11, r21
     e8e:	c6 01       	movw	r24, r12
     e90:	0e 94 63 08 	call	0x10c6	; 0x10c6 <strnlen_P>
     e94:	8c 01       	movw	r16, r24
     e96:	50 e8       	ldi	r21, 0x80	; 128
     e98:	f5 2a       	or	r15, r21
     e9a:	f3 fe       	sbrs	r15, 3
     e9c:	07 c0       	rjmp	.+14     	; 0xeac <vfprintf+0x1a0>
     e9e:	1a c0       	rjmp	.+52     	; 0xed4 <vfprintf+0x1c8>
     ea0:	80 e2       	ldi	r24, 0x20	; 32
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	b3 01       	movw	r22, r6
     ea6:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
     eaa:	ea 94       	dec	r14
     eac:	8e 2d       	mov	r24, r14
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	08 17       	cp	r16, r24
     eb2:	19 07       	cpc	r17, r25
     eb4:	a8 f3       	brcs	.-22     	; 0xea0 <vfprintf+0x194>
     eb6:	0e c0       	rjmp	.+28     	; 0xed4 <vfprintf+0x1c8>
     eb8:	f6 01       	movw	r30, r12
     eba:	f7 fc       	sbrc	r15, 7
     ebc:	85 91       	lpm	r24, Z+
     ebe:	f7 fe       	sbrs	r15, 7
     ec0:	81 91       	ld	r24, Z+
     ec2:	6f 01       	movw	r12, r30
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	b3 01       	movw	r22, r6
     ec8:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
     ecc:	e1 10       	cpse	r14, r1
     ece:	ea 94       	dec	r14
     ed0:	01 50       	subi	r16, 0x01	; 1
     ed2:	10 40       	sbci	r17, 0x00	; 0
     ed4:	01 15       	cp	r16, r1
     ed6:	11 05       	cpc	r17, r1
     ed8:	79 f7       	brne	.-34     	; 0xeb8 <vfprintf+0x1ac>
     eda:	ea c0       	rjmp	.+468    	; 0x10b0 <vfprintf+0x3a4>
     edc:	94 36       	cpi	r25, 0x64	; 100
     ede:	11 f0       	breq	.+4      	; 0xee4 <vfprintf+0x1d8>
     ee0:	99 36       	cpi	r25, 0x69	; 105
     ee2:	69 f5       	brne	.+90     	; 0xf3e <vfprintf+0x232>
     ee4:	f7 fe       	sbrs	r15, 7
     ee6:	08 c0       	rjmp	.+16     	; 0xef8 <vfprintf+0x1ec>
     ee8:	f5 01       	movw	r30, r10
     eea:	20 81       	ld	r18, Z
     eec:	31 81       	ldd	r19, Z+1	; 0x01
     eee:	42 81       	ldd	r20, Z+2	; 0x02
     ef0:	53 81       	ldd	r21, Z+3	; 0x03
     ef2:	84 e0       	ldi	r24, 0x04	; 4
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	0a c0       	rjmp	.+20     	; 0xf0c <vfprintf+0x200>
     ef8:	f5 01       	movw	r30, r10
     efa:	80 81       	ld	r24, Z
     efc:	91 81       	ldd	r25, Z+1	; 0x01
     efe:	9c 01       	movw	r18, r24
     f00:	44 27       	eor	r20, r20
     f02:	37 fd       	sbrc	r19, 7
     f04:	40 95       	com	r20
     f06:	54 2f       	mov	r21, r20
     f08:	82 e0       	ldi	r24, 0x02	; 2
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	a8 0e       	add	r10, r24
     f0e:	b9 1e       	adc	r11, r25
     f10:	9f e6       	ldi	r25, 0x6F	; 111
     f12:	f9 22       	and	r15, r25
     f14:	57 ff       	sbrs	r21, 7
     f16:	09 c0       	rjmp	.+18     	; 0xf2a <vfprintf+0x21e>
     f18:	50 95       	com	r21
     f1a:	40 95       	com	r20
     f1c:	30 95       	com	r19
     f1e:	21 95       	neg	r18
     f20:	3f 4f       	sbci	r19, 0xFF	; 255
     f22:	4f 4f       	sbci	r20, 0xFF	; 255
     f24:	5f 4f       	sbci	r21, 0xFF	; 255
     f26:	e0 e8       	ldi	r30, 0x80	; 128
     f28:	fe 2a       	or	r15, r30
     f2a:	ca 01       	movw	r24, r20
     f2c:	b9 01       	movw	r22, r18
     f2e:	a1 01       	movw	r20, r2
     f30:	2a e0       	ldi	r18, 0x0A	; 10
     f32:	30 e0       	ldi	r19, 0x00	; 0
     f34:	0e 94 a5 08 	call	0x114a	; 0x114a <__ultoa_invert>
     f38:	d8 2e       	mov	r13, r24
     f3a:	d2 18       	sub	r13, r2
     f3c:	40 c0       	rjmp	.+128    	; 0xfbe <vfprintf+0x2b2>
     f3e:	95 37       	cpi	r25, 0x75	; 117
     f40:	29 f4       	brne	.+10     	; 0xf4c <vfprintf+0x240>
     f42:	1f 2d       	mov	r17, r15
     f44:	1f 7e       	andi	r17, 0xEF	; 239
     f46:	2a e0       	ldi	r18, 0x0A	; 10
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	1d c0       	rjmp	.+58     	; 0xf86 <vfprintf+0x27a>
     f4c:	1f 2d       	mov	r17, r15
     f4e:	19 7f       	andi	r17, 0xF9	; 249
     f50:	9f 36       	cpi	r25, 0x6F	; 111
     f52:	61 f0       	breq	.+24     	; 0xf6c <vfprintf+0x260>
     f54:	90 37       	cpi	r25, 0x70	; 112
     f56:	20 f4       	brcc	.+8      	; 0xf60 <vfprintf+0x254>
     f58:	98 35       	cpi	r25, 0x58	; 88
     f5a:	09 f0       	breq	.+2      	; 0xf5e <vfprintf+0x252>
     f5c:	ac c0       	rjmp	.+344    	; 0x10b6 <vfprintf+0x3aa>
     f5e:	0f c0       	rjmp	.+30     	; 0xf7e <vfprintf+0x272>
     f60:	90 37       	cpi	r25, 0x70	; 112
     f62:	39 f0       	breq	.+14     	; 0xf72 <vfprintf+0x266>
     f64:	98 37       	cpi	r25, 0x78	; 120
     f66:	09 f0       	breq	.+2      	; 0xf6a <vfprintf+0x25e>
     f68:	a6 c0       	rjmp	.+332    	; 0x10b6 <vfprintf+0x3aa>
     f6a:	04 c0       	rjmp	.+8      	; 0xf74 <vfprintf+0x268>
     f6c:	28 e0       	ldi	r18, 0x08	; 8
     f6e:	30 e0       	ldi	r19, 0x00	; 0
     f70:	0a c0       	rjmp	.+20     	; 0xf86 <vfprintf+0x27a>
     f72:	10 61       	ori	r17, 0x10	; 16
     f74:	14 fd       	sbrc	r17, 4
     f76:	14 60       	ori	r17, 0x04	; 4
     f78:	20 e1       	ldi	r18, 0x10	; 16
     f7a:	30 e0       	ldi	r19, 0x00	; 0
     f7c:	04 c0       	rjmp	.+8      	; 0xf86 <vfprintf+0x27a>
     f7e:	14 fd       	sbrc	r17, 4
     f80:	16 60       	ori	r17, 0x06	; 6
     f82:	20 e1       	ldi	r18, 0x10	; 16
     f84:	32 e0       	ldi	r19, 0x02	; 2
     f86:	17 ff       	sbrs	r17, 7
     f88:	08 c0       	rjmp	.+16     	; 0xf9a <vfprintf+0x28e>
     f8a:	f5 01       	movw	r30, r10
     f8c:	60 81       	ld	r22, Z
     f8e:	71 81       	ldd	r23, Z+1	; 0x01
     f90:	82 81       	ldd	r24, Z+2	; 0x02
     f92:	93 81       	ldd	r25, Z+3	; 0x03
     f94:	44 e0       	ldi	r20, 0x04	; 4
     f96:	50 e0       	ldi	r21, 0x00	; 0
     f98:	08 c0       	rjmp	.+16     	; 0xfaa <vfprintf+0x29e>
     f9a:	f5 01       	movw	r30, r10
     f9c:	80 81       	ld	r24, Z
     f9e:	91 81       	ldd	r25, Z+1	; 0x01
     fa0:	bc 01       	movw	r22, r24
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	42 e0       	ldi	r20, 0x02	; 2
     fa8:	50 e0       	ldi	r21, 0x00	; 0
     faa:	a4 0e       	add	r10, r20
     fac:	b5 1e       	adc	r11, r21
     fae:	a1 01       	movw	r20, r2
     fb0:	0e 94 a5 08 	call	0x114a	; 0x114a <__ultoa_invert>
     fb4:	d8 2e       	mov	r13, r24
     fb6:	d2 18       	sub	r13, r2
     fb8:	8f e7       	ldi	r24, 0x7F	; 127
     fba:	f8 2e       	mov	r15, r24
     fbc:	f1 22       	and	r15, r17
     fbe:	f6 fe       	sbrs	r15, 6
     fc0:	0b c0       	rjmp	.+22     	; 0xfd8 <vfprintf+0x2cc>
     fc2:	5e ef       	ldi	r21, 0xFE	; 254
     fc4:	f5 22       	and	r15, r21
     fc6:	d9 14       	cp	r13, r9
     fc8:	38 f4       	brcc	.+14     	; 0xfd8 <vfprintf+0x2cc>
     fca:	f4 fe       	sbrs	r15, 4
     fcc:	07 c0       	rjmp	.+14     	; 0xfdc <vfprintf+0x2d0>
     fce:	f2 fc       	sbrc	r15, 2
     fd0:	05 c0       	rjmp	.+10     	; 0xfdc <vfprintf+0x2d0>
     fd2:	8f ee       	ldi	r24, 0xEF	; 239
     fd4:	f8 22       	and	r15, r24
     fd6:	02 c0       	rjmp	.+4      	; 0xfdc <vfprintf+0x2d0>
     fd8:	1d 2d       	mov	r17, r13
     fda:	01 c0       	rjmp	.+2      	; 0xfde <vfprintf+0x2d2>
     fdc:	19 2d       	mov	r17, r9
     fde:	f4 fe       	sbrs	r15, 4
     fe0:	0d c0       	rjmp	.+26     	; 0xffc <vfprintf+0x2f0>
     fe2:	fe 01       	movw	r30, r28
     fe4:	ed 0d       	add	r30, r13
     fe6:	f1 1d       	adc	r31, r1
     fe8:	80 81       	ld	r24, Z
     fea:	80 33       	cpi	r24, 0x30	; 48
     fec:	19 f4       	brne	.+6      	; 0xff4 <vfprintf+0x2e8>
     fee:	99 ee       	ldi	r25, 0xE9	; 233
     ff0:	f9 22       	and	r15, r25
     ff2:	08 c0       	rjmp	.+16     	; 0x1004 <vfprintf+0x2f8>
     ff4:	1f 5f       	subi	r17, 0xFF	; 255
     ff6:	f2 fe       	sbrs	r15, 2
     ff8:	05 c0       	rjmp	.+10     	; 0x1004 <vfprintf+0x2f8>
     ffa:	03 c0       	rjmp	.+6      	; 0x1002 <vfprintf+0x2f6>
     ffc:	8f 2d       	mov	r24, r15
     ffe:	86 78       	andi	r24, 0x86	; 134
    1000:	09 f0       	breq	.+2      	; 0x1004 <vfprintf+0x2f8>
    1002:	1f 5f       	subi	r17, 0xFF	; 255
    1004:	0f 2d       	mov	r16, r15
    1006:	f3 fc       	sbrc	r15, 3
    1008:	14 c0       	rjmp	.+40     	; 0x1032 <vfprintf+0x326>
    100a:	f0 fe       	sbrs	r15, 0
    100c:	0f c0       	rjmp	.+30     	; 0x102c <vfprintf+0x320>
    100e:	1e 15       	cp	r17, r14
    1010:	10 f0       	brcs	.+4      	; 0x1016 <vfprintf+0x30a>
    1012:	9d 2c       	mov	r9, r13
    1014:	0b c0       	rjmp	.+22     	; 0x102c <vfprintf+0x320>
    1016:	9d 2c       	mov	r9, r13
    1018:	9e 0c       	add	r9, r14
    101a:	91 1a       	sub	r9, r17
    101c:	1e 2d       	mov	r17, r14
    101e:	06 c0       	rjmp	.+12     	; 0x102c <vfprintf+0x320>
    1020:	80 e2       	ldi	r24, 0x20	; 32
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	b3 01       	movw	r22, r6
    1026:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
    102a:	1f 5f       	subi	r17, 0xFF	; 255
    102c:	1e 15       	cp	r17, r14
    102e:	c0 f3       	brcs	.-16     	; 0x1020 <vfprintf+0x314>
    1030:	04 c0       	rjmp	.+8      	; 0x103a <vfprintf+0x32e>
    1032:	1e 15       	cp	r17, r14
    1034:	10 f4       	brcc	.+4      	; 0x103a <vfprintf+0x32e>
    1036:	e1 1a       	sub	r14, r17
    1038:	01 c0       	rjmp	.+2      	; 0x103c <vfprintf+0x330>
    103a:	ee 24       	eor	r14, r14
    103c:	04 ff       	sbrs	r16, 4
    103e:	0f c0       	rjmp	.+30     	; 0x105e <vfprintf+0x352>
    1040:	80 e3       	ldi	r24, 0x30	; 48
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	b3 01       	movw	r22, r6
    1046:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
    104a:	02 ff       	sbrs	r16, 2
    104c:	1d c0       	rjmp	.+58     	; 0x1088 <vfprintf+0x37c>
    104e:	01 fd       	sbrc	r16, 1
    1050:	03 c0       	rjmp	.+6      	; 0x1058 <vfprintf+0x34c>
    1052:	88 e7       	ldi	r24, 0x78	; 120
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	0e c0       	rjmp	.+28     	; 0x1074 <vfprintf+0x368>
    1058:	88 e5       	ldi	r24, 0x58	; 88
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	0b c0       	rjmp	.+22     	; 0x1074 <vfprintf+0x368>
    105e:	80 2f       	mov	r24, r16
    1060:	86 78       	andi	r24, 0x86	; 134
    1062:	91 f0       	breq	.+36     	; 0x1088 <vfprintf+0x37c>
    1064:	01 ff       	sbrs	r16, 1
    1066:	02 c0       	rjmp	.+4      	; 0x106c <vfprintf+0x360>
    1068:	8b e2       	ldi	r24, 0x2B	; 43
    106a:	01 c0       	rjmp	.+2      	; 0x106e <vfprintf+0x362>
    106c:	80 e2       	ldi	r24, 0x20	; 32
    106e:	f7 fc       	sbrc	r15, 7
    1070:	8d e2       	ldi	r24, 0x2D	; 45
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	b3 01       	movw	r22, r6
    1076:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
    107a:	06 c0       	rjmp	.+12     	; 0x1088 <vfprintf+0x37c>
    107c:	80 e3       	ldi	r24, 0x30	; 48
    107e:	90 e0       	ldi	r25, 0x00	; 0
    1080:	b3 01       	movw	r22, r6
    1082:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
    1086:	9a 94       	dec	r9
    1088:	d9 14       	cp	r13, r9
    108a:	c0 f3       	brcs	.-16     	; 0x107c <vfprintf+0x370>
    108c:	da 94       	dec	r13
    108e:	f1 01       	movw	r30, r2
    1090:	ed 0d       	add	r30, r13
    1092:	f1 1d       	adc	r31, r1
    1094:	80 81       	ld	r24, Z
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	b3 01       	movw	r22, r6
    109a:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
    109e:	dd 20       	and	r13, r13
    10a0:	a9 f7       	brne	.-22     	; 0x108c <vfprintf+0x380>
    10a2:	06 c0       	rjmp	.+12     	; 0x10b0 <vfprintf+0x3a4>
    10a4:	80 e2       	ldi	r24, 0x20	; 32
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	b3 01       	movw	r22, r6
    10aa:	0e 94 79 08 	call	0x10f2	; 0x10f2 <fputc>
    10ae:	ea 94       	dec	r14
    10b0:	ee 20       	and	r14, r14
    10b2:	c1 f7       	brne	.-16     	; 0x10a4 <vfprintf+0x398>
    10b4:	43 ce       	rjmp	.-890    	; 0xd3c <vfprintf+0x30>
    10b6:	f3 01       	movw	r30, r6
    10b8:	66 81       	ldd	r22, Z+6	; 0x06
    10ba:	77 81       	ldd	r23, Z+7	; 0x07
    10bc:	cb 01       	movw	r24, r22
    10be:	2b 96       	adiw	r28, 0x0b	; 11
    10c0:	e2 e1       	ldi	r30, 0x12	; 18
    10c2:	0c 94 1f 09 	jmp	0x123e	; 0x123e <__epilogue_restores__>

000010c6 <strnlen_P>:
    10c6:	fc 01       	movw	r30, r24
    10c8:	05 90       	lpm	r0, Z+
    10ca:	61 50       	subi	r22, 0x01	; 1
    10cc:	70 40       	sbci	r23, 0x00	; 0
    10ce:	01 10       	cpse	r0, r1
    10d0:	d8 f7       	brcc	.-10     	; 0x10c8 <strnlen_P+0x2>
    10d2:	80 95       	com	r24
    10d4:	90 95       	com	r25
    10d6:	8e 0f       	add	r24, r30
    10d8:	9f 1f       	adc	r25, r31
    10da:	08 95       	ret

000010dc <strnlen>:
    10dc:	fc 01       	movw	r30, r24
    10de:	61 50       	subi	r22, 0x01	; 1
    10e0:	70 40       	sbci	r23, 0x00	; 0
    10e2:	01 90       	ld	r0, Z+
    10e4:	01 10       	cpse	r0, r1
    10e6:	d8 f7       	brcc	.-10     	; 0x10de <strnlen+0x2>
    10e8:	80 95       	com	r24
    10ea:	90 95       	com	r25
    10ec:	8e 0f       	add	r24, r30
    10ee:	9f 1f       	adc	r25, r31
    10f0:	08 95       	ret

000010f2 <fputc>:
    10f2:	0f 93       	push	r16
    10f4:	1f 93       	push	r17
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	8c 01       	movw	r16, r24
    10fc:	eb 01       	movw	r28, r22
    10fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1100:	81 ff       	sbrs	r24, 1
    1102:	1b c0       	rjmp	.+54     	; 0x113a <fputc+0x48>
    1104:	82 ff       	sbrs	r24, 2
    1106:	0d c0       	rjmp	.+26     	; 0x1122 <fputc+0x30>
    1108:	2e 81       	ldd	r18, Y+6	; 0x06
    110a:	3f 81       	ldd	r19, Y+7	; 0x07
    110c:	8c 81       	ldd	r24, Y+4	; 0x04
    110e:	9d 81       	ldd	r25, Y+5	; 0x05
    1110:	28 17       	cp	r18, r24
    1112:	39 07       	cpc	r19, r25
    1114:	64 f4       	brge	.+24     	; 0x112e <fputc+0x3c>
    1116:	e8 81       	ld	r30, Y
    1118:	f9 81       	ldd	r31, Y+1	; 0x01
    111a:	01 93       	st	Z+, r16
    111c:	f9 83       	std	Y+1, r31	; 0x01
    111e:	e8 83       	st	Y, r30
    1120:	06 c0       	rjmp	.+12     	; 0x112e <fputc+0x3c>
    1122:	e8 85       	ldd	r30, Y+8	; 0x08
    1124:	f9 85       	ldd	r31, Y+9	; 0x09
    1126:	80 2f       	mov	r24, r16
    1128:	09 95       	icall
    112a:	89 2b       	or	r24, r25
    112c:	31 f4       	brne	.+12     	; 0x113a <fputc+0x48>
    112e:	8e 81       	ldd	r24, Y+6	; 0x06
    1130:	9f 81       	ldd	r25, Y+7	; 0x07
    1132:	01 96       	adiw	r24, 0x01	; 1
    1134:	9f 83       	std	Y+7, r25	; 0x07
    1136:	8e 83       	std	Y+6, r24	; 0x06
    1138:	02 c0       	rjmp	.+4      	; 0x113e <fputc+0x4c>
    113a:	0f ef       	ldi	r16, 0xFF	; 255
    113c:	1f ef       	ldi	r17, 0xFF	; 255
    113e:	c8 01       	movw	r24, r16
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	1f 91       	pop	r17
    1146:	0f 91       	pop	r16
    1148:	08 95       	ret

0000114a <__ultoa_invert>:
    114a:	fa 01       	movw	r30, r20
    114c:	aa 27       	eor	r26, r26
    114e:	28 30       	cpi	r18, 0x08	; 8
    1150:	51 f1       	breq	.+84     	; 0x11a6 <__ultoa_invert+0x5c>
    1152:	20 31       	cpi	r18, 0x10	; 16
    1154:	81 f1       	breq	.+96     	; 0x11b6 <__ultoa_invert+0x6c>
    1156:	e8 94       	clt
    1158:	6f 93       	push	r22
    115a:	6e 7f       	andi	r22, 0xFE	; 254
    115c:	6e 5f       	subi	r22, 0xFE	; 254
    115e:	7f 4f       	sbci	r23, 0xFF	; 255
    1160:	8f 4f       	sbci	r24, 0xFF	; 255
    1162:	9f 4f       	sbci	r25, 0xFF	; 255
    1164:	af 4f       	sbci	r26, 0xFF	; 255
    1166:	b1 e0       	ldi	r27, 0x01	; 1
    1168:	3e d0       	rcall	.+124    	; 0x11e6 <__ultoa_invert+0x9c>
    116a:	b4 e0       	ldi	r27, 0x04	; 4
    116c:	3c d0       	rcall	.+120    	; 0x11e6 <__ultoa_invert+0x9c>
    116e:	67 0f       	add	r22, r23
    1170:	78 1f       	adc	r23, r24
    1172:	89 1f       	adc	r24, r25
    1174:	9a 1f       	adc	r25, r26
    1176:	a1 1d       	adc	r26, r1
    1178:	68 0f       	add	r22, r24
    117a:	79 1f       	adc	r23, r25
    117c:	8a 1f       	adc	r24, r26
    117e:	91 1d       	adc	r25, r1
    1180:	a1 1d       	adc	r26, r1
    1182:	6a 0f       	add	r22, r26
    1184:	71 1d       	adc	r23, r1
    1186:	81 1d       	adc	r24, r1
    1188:	91 1d       	adc	r25, r1
    118a:	a1 1d       	adc	r26, r1
    118c:	20 d0       	rcall	.+64     	; 0x11ce <__ultoa_invert+0x84>
    118e:	09 f4       	brne	.+2      	; 0x1192 <__ultoa_invert+0x48>
    1190:	68 94       	set
    1192:	3f 91       	pop	r19
    1194:	2a e0       	ldi	r18, 0x0A	; 10
    1196:	26 9f       	mul	r18, r22
    1198:	11 24       	eor	r1, r1
    119a:	30 19       	sub	r19, r0
    119c:	30 5d       	subi	r19, 0xD0	; 208
    119e:	31 93       	st	Z+, r19
    11a0:	de f6       	brtc	.-74     	; 0x1158 <__ultoa_invert+0xe>
    11a2:	cf 01       	movw	r24, r30
    11a4:	08 95       	ret
    11a6:	46 2f       	mov	r20, r22
    11a8:	47 70       	andi	r20, 0x07	; 7
    11aa:	40 5d       	subi	r20, 0xD0	; 208
    11ac:	41 93       	st	Z+, r20
    11ae:	b3 e0       	ldi	r27, 0x03	; 3
    11b0:	0f d0       	rcall	.+30     	; 0x11d0 <__ultoa_invert+0x86>
    11b2:	c9 f7       	brne	.-14     	; 0x11a6 <__ultoa_invert+0x5c>
    11b4:	f6 cf       	rjmp	.-20     	; 0x11a2 <__ultoa_invert+0x58>
    11b6:	46 2f       	mov	r20, r22
    11b8:	4f 70       	andi	r20, 0x0F	; 15
    11ba:	40 5d       	subi	r20, 0xD0	; 208
    11bc:	4a 33       	cpi	r20, 0x3A	; 58
    11be:	18 f0       	brcs	.+6      	; 0x11c6 <__ultoa_invert+0x7c>
    11c0:	49 5d       	subi	r20, 0xD9	; 217
    11c2:	31 fd       	sbrc	r19, 1
    11c4:	40 52       	subi	r20, 0x20	; 32
    11c6:	41 93       	st	Z+, r20
    11c8:	02 d0       	rcall	.+4      	; 0x11ce <__ultoa_invert+0x84>
    11ca:	a9 f7       	brne	.-22     	; 0x11b6 <__ultoa_invert+0x6c>
    11cc:	ea cf       	rjmp	.-44     	; 0x11a2 <__ultoa_invert+0x58>
    11ce:	b4 e0       	ldi	r27, 0x04	; 4
    11d0:	a6 95       	lsr	r26
    11d2:	97 95       	ror	r25
    11d4:	87 95       	ror	r24
    11d6:	77 95       	ror	r23
    11d8:	67 95       	ror	r22
    11da:	ba 95       	dec	r27
    11dc:	c9 f7       	brne	.-14     	; 0x11d0 <__ultoa_invert+0x86>
    11de:	00 97       	sbiw	r24, 0x00	; 0
    11e0:	61 05       	cpc	r22, r1
    11e2:	71 05       	cpc	r23, r1
    11e4:	08 95       	ret
    11e6:	9b 01       	movw	r18, r22
    11e8:	ac 01       	movw	r20, r24
    11ea:	0a 2e       	mov	r0, r26
    11ec:	06 94       	lsr	r0
    11ee:	57 95       	ror	r21
    11f0:	47 95       	ror	r20
    11f2:	37 95       	ror	r19
    11f4:	27 95       	ror	r18
    11f6:	ba 95       	dec	r27
    11f8:	c9 f7       	brne	.-14     	; 0x11ec <__ultoa_invert+0xa2>
    11fa:	62 0f       	add	r22, r18
    11fc:	73 1f       	adc	r23, r19
    11fe:	84 1f       	adc	r24, r20
    1200:	95 1f       	adc	r25, r21
    1202:	a0 1d       	adc	r26, r0
    1204:	08 95       	ret

00001206 <__prologue_saves__>:
    1206:	2f 92       	push	r2
    1208:	3f 92       	push	r3
    120a:	4f 92       	push	r4
    120c:	5f 92       	push	r5
    120e:	6f 92       	push	r6
    1210:	7f 92       	push	r7
    1212:	8f 92       	push	r8
    1214:	9f 92       	push	r9
    1216:	af 92       	push	r10
    1218:	bf 92       	push	r11
    121a:	cf 92       	push	r12
    121c:	df 92       	push	r13
    121e:	ef 92       	push	r14
    1220:	ff 92       	push	r15
    1222:	0f 93       	push	r16
    1224:	1f 93       	push	r17
    1226:	cf 93       	push	r28
    1228:	df 93       	push	r29
    122a:	cd b7       	in	r28, 0x3d	; 61
    122c:	de b7       	in	r29, 0x3e	; 62
    122e:	ca 1b       	sub	r28, r26
    1230:	db 0b       	sbc	r29, r27
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	cd bf       	out	0x3d, r28	; 61
    123c:	09 94       	ijmp

0000123e <__epilogue_restores__>:
    123e:	2a 88       	ldd	r2, Y+18	; 0x12
    1240:	39 88       	ldd	r3, Y+17	; 0x11
    1242:	48 88       	ldd	r4, Y+16	; 0x10
    1244:	5f 84       	ldd	r5, Y+15	; 0x0f
    1246:	6e 84       	ldd	r6, Y+14	; 0x0e
    1248:	7d 84       	ldd	r7, Y+13	; 0x0d
    124a:	8c 84       	ldd	r8, Y+12	; 0x0c
    124c:	9b 84       	ldd	r9, Y+11	; 0x0b
    124e:	aa 84       	ldd	r10, Y+10	; 0x0a
    1250:	b9 84       	ldd	r11, Y+9	; 0x09
    1252:	c8 84       	ldd	r12, Y+8	; 0x08
    1254:	df 80       	ldd	r13, Y+7	; 0x07
    1256:	ee 80       	ldd	r14, Y+6	; 0x06
    1258:	fd 80       	ldd	r15, Y+5	; 0x05
    125a:	0c 81       	ldd	r16, Y+4	; 0x04
    125c:	1b 81       	ldd	r17, Y+3	; 0x03
    125e:	aa 81       	ldd	r26, Y+2	; 0x02
    1260:	b9 81       	ldd	r27, Y+1	; 0x01
    1262:	ce 0f       	add	r28, r30
    1264:	d1 1d       	adc	r29, r1
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	cd bf       	out	0x3d, r28	; 61
    1270:	ed 01       	movw	r28, r26
    1272:	08 95       	ret

00001274 <_exit>:
    1274:	f8 94       	cli

00001276 <__stop_program>:
    1276:	ff cf       	rjmp	.-2      	; 0x1276 <__stop_program>
